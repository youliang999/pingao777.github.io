{"meta":{"title":"瞎说","subtitle":"哈哈","description":"Java Python R 机器学习 统计 扯淡","author":"pingao777","url":"https://pingao777.github.io"},"pages":[{"title":"About","date":"2018-01-11T14:00:11.204Z","updated":"2018-01-11T14:00:11.204Z","comments":true,"path":"about/index.html","permalink":"https://pingao777.github.io/about/index.html","excerpt":"","text":"GitHub: https://github.com/pingao777 扯自己的淡，让别人去喷吧！"},{"title":"Categories","date":"2018-01-11T14:00:11.204Z","updated":"2018-01-11T14:00:11.204Z","comments":true,"path":"categories/index.html","permalink":"https://pingao777.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-01-11T14:00:11.204Z","updated":"2018-01-11T14:00:11.204Z","comments":true,"path":"tags/index.html","permalink":"https://pingao777.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"马上TI了，有一起玩的道友吗","slug":"马上TI了，有一起玩的道友吗","date":"2018-08-10T13:35:49.000Z","updated":"2018-08-10T13:44:15.341Z","comments":true,"path":"2018/08/10/马上TI了，有一起玩的道友吗/","link":"","permalink":"https://pingao777.github.io/2018/08/10/马上TI了，有一起玩的道友吗/","excerpt":"","text":"马上TI了，又到了神奇的偶数年，希望中国军团如愿以偿。老年dota玩家不能亲临现场加油助威，只能在家多玩几场游戏贡献点电费，求一起玩的d友，分数2000左右吧，娱乐局，主要周末玩。","categories":[{"name":"七七八八","slug":"七七八八","permalink":"https://pingao777.github.io/categories/七七八八/"}],"tags":[{"name":"Dota","slug":"Dota","permalink":"https://pingao777.github.io/tags/Dota/"}]},{"title":"谁说大象不能跳舞：基于Java的Markdown预览插件","slug":"谁说大象不能跳舞：基于Java的Markdown预览插件","date":"2018-08-04T03:49:59.000Z","updated":"2018-08-09T14:01:17.790Z","comments":true,"path":"2018/08/04/谁说大象不能跳舞：基于Java的Markdown预览插件/","link":"","permalink":"https://pingao777.github.io/2018/08/04/谁说大象不能跳舞：基于Java的Markdown预览插件/","excerpt":"Java一直以来都给人留下了笨重的印象，按说插件这种轻量的任务根本和Java没啥关系，但是这次我要霸王硬上弓，让大象跳次舞。 跳什么舞呢？这是个问题，突然想起写博客一直困扰自己的一个问题：我一直使用Vim编写Markdown，有时候难免想看看效果，欣赏下文字跳动的样子，但是Vim不支持预览，自己一直用Chrome一款插件Markdown Viewer进行预览，遗憾的是这款插件不支持动态刷新也不支持同步滚动，所以如果你没有一下点出十个信号的手速，这个操作是比较尴尬的。既然这样，能不能用Java整个插件呢？","text":"Java一直以来都给人留下了笨重的印象，按说插件这种轻量的任务根本和Java没啥关系，但是这次我要霸王硬上弓，让大象跳次舞。 跳什么舞呢？这是个问题，突然想起写博客一直困扰自己的一个问题：我一直使用Vim编写Markdown，有时候难免想看看效果，欣赏下文字跳动的样子，但是Vim不支持预览，自己一直用Chrome一款插件Markdown Viewer进行预览，遗憾的是这款插件不支持动态刷新也不支持同步滚动，所以如果你没有一下点出十个信号的手速，这个操作是比较尴尬的。既然这样，能不能用Java整个插件呢？ 整体思路既然现在Markdown Viewer只能显示不能滚动，那么通过程序将Vim的某种位置信息传给浏览器，然后调用js滚动到这个位置不就可以了吗？想让浏览器显示网页而且网页的内容还得不停的变，需要一个Web服务器，这正是Java的强项。从浏览器到Java的路走通了，但是Vim到Java的路怎么走呢？由于Vim不支持Java，二者怎么通信呢，这时看到著名的胶水语言，编程语言界的媒婆Python是被Vim支持的，方案有了：让Python与Java通信。好，这样整个流程就通了。整体框架如下所示： Java服务器Web这片领域简直就是Java的主场，自然一点问题没有。以前学过Netty，一直没有派上用场，这次终于可以小试牛刀了。 123456789101112131415161718192021222324public class HttpRequestHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123; private MarkDownServer server; public HttpRequestHandler(MarkDownServer server) &#123; this.server = server; &#125; @Override public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) &#123; String uri = request.uri(); if (uri.startsWith(\"/index\")) &#123; index(ctx, request); &#125; else if (uri.startsWith(\"/ws\")) &#123; ctx.fireChannelRead(request.retain()); &#125; else if (uri.startsWith(\"/js\") || uri.startsWith(\"/css\")) &#123; transferStaticFile(ctx, request); &#125; else if (uri.startsWith(\"/image\")) &#123; image(ctx, request); &#125; else &#123; commonResponse(ctx, request, FileUtils.getBytes(\"How do you do\"), MiMeType.PLAIN); &#125; &#125;&#125; 上面即是Web服务的框架程序，细节就不贴了。但是有几个问题大家要注意： 服务器怎么和浏览器通信？ 网页里的js和css怎么返回？ Python怎么和Java通信？ 上面的程序处理的正是前两个问题。 先说服务器怎么和浏览器通信，最初定的是ajax，但是后来找到一种更好的方案WebSocket，WebSocket可以让浏览器和服务器保持长连接，有更好的流畅性和速度，这就是上面/ws所处理的内容。 第二个问题，网页中的静态文件js和css需要让服务器返回，就像tomcat这些通用服务器做的那样，这里没什么复杂的，就是一个简单的文件读写，只有一点需要注意：文件的编码，否则页面会乱码。 第三个问题，Python怎么和Java通信，最初采用的是py4j，优点是这个库可以直接在Python里调用Java程序，缺点是需要安装额外的库，对于有着代码洁癖的我不是一个完美的方案，后来一想既然已经有了Web服务器，直接使用Http不就可以了，所以将方案又改为使用Http与Java通信，经过实验，这个方案虽然不用安装额外的库了，但是由于Python的原装urllib库不能保持长连接，随着连接的增多，速度会慢慢降下来，看来还得另寻出路。 12345678910111213141516171819202122232425262728private class SocketServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ByteBuf in = (ByteBuf) msg; String string = in.toString(CharsetUtil.UTF_8); LOGGER.info(\"Server received: \" + string); String[] data = string.split(SEP); switch (data[0]) &#123; case \"start\": server = MarkDownServer.getInstance(); server.setTheme(data[2]); server.start(Integer.parseInt(data[1])); break; case \"sync\": server.broadcast(\"sync\", data[1], Base64Utils.decode2String(data[2]), Integer.parseInt(data[3])); break; case \"close\": server.broadcast(\"close\", data[1], \"\", 1); break; case \"stop\": server.destroy(); System.exit(0); break; default: LOGGER.info(\"Command &#123;&#125; is unknown\", data[0]); &#125; &#125;&#125; 这就是最终的解决方案：返璞归真，直接使用最底层的Socket与Java通信。经过实验，速度提升明显，而且由于Socket客户端和服务端可以保持长连接，没有运行一段时间，速度变慢的缺点。 通信主要包含四种情况： start：启动Http服务器 sync：同步内容和位置 close：关闭预览窗口 stop：停止Http服务器，退出系统 Java-&gt;浏览器1234567891011121314151617181920212223242526272829303132333435363738394041424344var url = 'ws://127.0.0.1:' + window.location.port + '/ws';if (!WebSocket) &#123; console.warn('WebSocket is not support');&#125; else &#123; console.log('Try to connect ' + url); var ws = new WebSocket(url); ws.onclose = function () &#123; console.log('Disconnected'); close(); &#125;; ws.onmessage = function (d) &#123; console.log('Response : ' + d.data.length); var data = JSON.parse(d.data); var path = $('#path'); if (path.val() === '') &#123; init(data); &#125; else &#123; if (path.val() === data.path) &#123; if (data.command === 'close') &#123; close() &#125; else if (data.command === 'sync') &#123; sync(data); &#125; &#125; &#125; &#125;;&#125;var init = function (data) &#123; $('title').html(data.path); $('#path').val(data.path); $('.markdown-body').html(''); markdown_refresh(data.units); highlight_code(); scroll_if_possible();&#125;;var sync = function (data) &#123; markdown_refresh(data.units); highlight_code(); scroll_if_possible();&#125;; 前端就是一个WebSoket客户端，接受两种指令：close和sync，前者用于关闭页面，后者用于同步信息。 大致的流程是浏览器第一次收到服务器消息调用init进行初始化，它会将网页的title和页面元素#path置为文件的路径，将.markdown-body清空，因为浏览器刚启动时会启动一个index介绍页面，需要将其清空，然后调用markdown_refresh刷新显示新的内容，内容显示后hightlight_code负责高亮其中的代码，最后用scroll_if_possible滚动到指定位置。往后浏览器每收到服务器消息都会调用sync同步信息和位置，sync和init内部代码差不多，我就不再赘述了。 Vim-&gt;Java以上走通了Java到浏览器的路，下面看看如何走Vim到Java的路，在整体思路中提到Vim支持Python，所以这条路的主角就是Python，最初是发送Http请求与Java交互，后来又改为使用Socket，原因参看Java服务器那一节。最终的代码如下： 123456789101112131415161718192021222324SEP = '\\r\\n\\r\\n'EOF = '$_@'s = Nonedef start(port, theme): global s s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(('127.0.0.1', 23789)) s.send('start' + SEP + str(port) + SEP + theme + EOF)def sync(path, content, bottom): s.send('sync' + SEP + path + SEP + base64.b64encode(content) + SEP + str(bottom) + EOF)def close(path): s.send('close' + SEP + path + EOF)def stop(): s.send('stop' + EOF) s.close() 变量解释：path表示打开文件的路径，content为buffer内容，bottom为当前窗口的末行。 这里的函数和Java Socket服务器那一节里处理的四种情况一一对应，想不起来的可以回去再看下。你可能注意到每次发送消息后面都加了一个EOF，这是因为Tcp是基于流的通信协议，需要一种策略告诉接受方什么时候是一条完整的消息，这里采用的是终结符的形式，即每条消息后面都加了一个EOF告知接收方已经接受了一条完整的消息。另外需要对content进行base64编码，因为content里可能包含一些特殊字符，传输过程中对这些字符处理不一致会导致出错。 下一步就是在Vimscript里调用Python，我就不贴代码了。 一步之遥至此，插件就基本编写完成了，似乎离成功只有一步之遥了，但成功往往没那么简单。运行一下，乍看起来效果还可以，但是存在两个比较严重的问题： MathJax抖动每次滚动时，如果页面里包含MathJax表达式，页面就会一抖一抖的。这是因为所有的内容都存在一个&lt;article&gt;&lt;/article&gt;标签里，前端每次加载内容，都要刷新内容里所有的MathJax表达式，表达式加载需要时间，未加载完成时有一个空的占位，加载完成使用真正的元素替换，类似网页中的图片加载流程，占位和真正的元素大小不一致，这样给人的感觉就是页面一抖一抖的，最初用的代码如下： 12345678910MathJax.Hub.Config(&#123;extensions: [\"tex2jax.js\"], jax: [\"input/TeX\", \"output/SVG\"], tex2jax: &#123; inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ] &#125;, messageStyle: \"none\"&#125;);MathJax.Hub.Queue([\"Typeset\", MathJax.Hub]); 那怎么解决呢？既然是因为刷新全部的MathJax表达式，那么不让它刷新全部，让它刷新的内容越少抖动不就越小了？查阅MathJax的文档，找到一个函数MathJax.Hub.Queue([&#39;Typeset&#39;, MathJax.Hub, element])，它只会刷新页面元素element里的表达式，修改服务器同步信息代码，改全量同步为增量同步，如果里面包含MathJax表达式就调用上述命令刷新。 新的前端代码如下： 123456789101112131415161718192021222324252627$.each(units, function (i, u) &#123; if (u.operate === 'REPLACE') &#123; if (u.id === 'toc_container') &#123; $('.markdown-body').css('padding-left', '200px'); var toc = $('#' + u.id); toc.html(u.content); toc.show(); &#125; else &#123; $('#' + u.id).replaceWith(u.content); &#125; &#125; else if (u.operate === 'APPEND') &#123; $('.markdown-body').append(u.content); &#125; else if (u.operate === 'REMOVE') &#123; if (u.id === 'toc_container') &#123; $('.markdown-body').css('padding-left', '45px'); var cot = $('#' + u.id); cot.html(''); cot.hide(); &#125; else &#123; $('#' + u.id).remove(); &#125; &#125; if (u.isMathJax === 1) &#123; MathJax.Hub.Queue(['Typeset', MathJax.Hub, u.id]); &#125;&#125;) 本地图片不显示由于浏览器安全策略的限制，页面的img标签不能打开本地图片，即形如&lt;img src=&#39;D:\\path-to-img.jpg&#39;/&gt;这种写法浏览器不会加载图片，而是提示“Not allowed to load local resource”。一般在文章未发布到网上时，图片地址往往写一个本地的绝对路径，如果不能显示本地图片的话将会大大影响方便性。那么该怎么办呢，第一种方法是写相对路径，即&lt;img src=&#39;/path-to-img.jpg&#39;/&gt;，这种方式有很大的局限性，即必须将图片放在一个位置，与网页呈一种相对关系；另一种是写的时候还是写绝对路径，经过程序转成服务器地址，然后通过服务器将图片返给浏览器。显然第二种方式更加灵活，核心代码如下： 12345678910111213private static void transformLocalImgSrc(Element element) &#123; Elements images = element.select(\"img\"); for (Element img : images) &#123; String src = img.attr(\"src\"); if (!src.startsWith(\"http\")) &#123; if (isWindows()) &#123; img.attr(\"src\", \"/image?path=\" + src.replace(\"\\\\\", \"\\\\\\\\\")); &#125; else &#123; img.attr(\"src\", \"/image?path=\" + src); &#125; &#125; &#125;&#125; 上面的代码将形如D:\\path-to-img.jpg的本地路径转成http://127.0.0.1:7788/image?path=D:\\\\path-to-img.jpg(windows系统，其他系统路径与此略有不同)，然后由服务器将图片内容返回。这样就绕过了浏览器的安全策略，实现本地图片的加载了。 阳光总在风雨后尽管经过了一些风雨，最后还是看到胜利的曙光了。这个项目够小，涵盖的语言和知识并不少，作为一个练手的项目还是不错的，如果碰巧还能给生活提供点便利，何乐而不为呢？想了解大象跳舞的更多细节请戳github。 效果如下： 参考资料： Netty in action write vim plugin in python","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pingao777.github.io/tags/Java/"},{"name":"Vim","slug":"Vim","permalink":"https://pingao777.github.io/tags/Vim/"},{"name":"Markdown","slug":"Markdown","permalink":"https://pingao777.github.io/tags/Markdown/"},{"name":"Python","slug":"Python","permalink":"https://pingao777.github.io/tags/Python/"}]},{"title":"Vim Markdown预览插件markdown-preview-sync","slug":"Vim Markdown预览插件markdown-preview-sync","date":"2018-07-29T02:24:06.000Z","updated":"2018-07-29T06:37:51.153Z","comments":true,"path":"2018/07/29/Vim Markdown预览插件markdown-preview-sync/","link":"","permalink":"https://pingao777.github.io/2018/07/29/Vim Markdown预览插件markdown-preview-sync/","excerpt":"花了大概两个星期整了个Vim预览插件markdown-preview-sync，主要参考了Markdown Viewer和markdown-preview.vim这两款插件，感谢这两款插件的作者。 支持如下特性： 代码高亮 MathJax 自定义CSS GFM-TABLE 目录TOC 运行效果如图：","text":"花了大概两个星期整了个Vim预览插件markdown-preview-sync，主要参考了Markdown Viewer和markdown-preview.vim这两款插件，感谢这两款插件的作者。 支持如下特性： 代码高亮 MathJax 自定义CSS GFM-TABLE 目录TOC 运行效果如图： 为了用户体验，预览并不是实时显示的，而是在换行时或保存时。这一点是有意为之的，毕竟大家对Markdown语法都了如指掌了，只是想偶尔看下效果。相信大家都有这样的体验，眼睛不停的在编辑屏和预览屏来回切换，眼睛很累，同时思路也很容易被打断，而且根据我个人的实验，同步频率太快会影响Vim的流畅性。 最后再啰嗦一句，欢迎大家使用并提出宝贵意见！","categories":[{"name":"七七八八","slug":"七七八八","permalink":"https://pingao777.github.io/categories/七七八八/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://pingao777.github.io/tags/Vim/"},{"name":"Markdown","slug":"Markdown","permalink":"https://pingao777.github.io/tags/Markdown/"}]},{"title":"Java的equals和hashCode方法浅谈","slug":"Java的equals和hashCode方法浅谈","date":"2018-07-02T08:20:39.000Z","updated":"2018-07-08T02:36:21.821Z","comments":true,"path":"2018/07/02/Java的equals和hashCode方法浅谈/","link":"","permalink":"https://pingao777.github.io/2018/07/02/Java的equals和hashCode方法浅谈/","excerpt":"一、概述equals和hashCode作为Java基础经常在面试中提到，比如下面几个问题： equals和==有什么区别？ equals和hashCode有什么关系？ equals和hashCode如何编写？ 对于第一个问题不少人只停留在字符串equals比较的是内容，==比较的是内存地址，而对equals的本质极少过问。第二个问题，大多数都知道答案，也有不少记反了，但是更进一步为什么是那样的关系，就不知道了。对于第三个问题，大部分人一上手就把方法签名写错了，就别谈正确的写出实现了。带着这些问题，接下来谈谈自己的一点理解。","text":"一、概述equals和hashCode作为Java基础经常在面试中提到，比如下面几个问题： equals和==有什么区别？ equals和hashCode有什么关系？ equals和hashCode如何编写？ 对于第一个问题不少人只停留在字符串equals比较的是内容，==比较的是内存地址，而对equals的本质极少过问。第二个问题，大多数都知道答案，也有不少记反了，但是更进一步为什么是那样的关系，就不知道了。对于第三个问题，大部分人一上手就把方法签名写错了，就别谈正确的写出实现了。带着这些问题，接下来谈谈自己的一点理解。 二、equals方法先来看见equals方法的签名，123public boolean equals(Object obj) &#123; return (this == obj);&#125; 可以看到入参是Object，很多人没有注意到这一点，上来就写错了。equals方法顾名思义就判断对象的相等性，默认实现就是==，那么说到二者的区别，个人理解，equals方法是一种用户定义的“逻辑等”，而==是一种“物理等”，用俗语解释就是，equals判断是否相同，==判断是否一样。 equals方法在编写的时候需要遵循以下原则： 自反性 对称性 传递性 一致性 下面展开说一下， 自反性的意思是，对于一个非null的对象x，x.equals(x)一定为true，这是显而易见的，无须赘述。 对称性，对于非null对象x、y，x.equals(y) == true，当且仅当y.equals(x) == true。来看一个来自《Effective Java》的例子， 12345678910111213141516171819202122232425// Broken - violates symmetry!public final class CaseInsensitiveString &#123; private final String s; public CaseInsensitiveString(String s) &#123; this.s = Objects.requireNonNull(s); &#125; // Broken - violates symmetry! @Override public boolean equals(Object o) &#123; if (o instanceof CaseInsensitiveString) return s.equalsIgnoreCase( ((CaseInsensitiveString) o).s); if (o instanceof String) // One-way interoperability! return s.equalsIgnoreCase((String) o); return false; &#125; ... // Remainder omitted&#125;CaseInsensitiveString cis = new CaseInsensitiveString(\"Polish\");String s = \"polish\";List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;();list.add(cis);// true or falselist.contains(s); 在JDK8运行list.contains(s)返回false，但是有的JDK可能会返回true，甚至直接崩溃，所以如果违反了对称性，程序的行为是不可预测的。 传递性，对于非null对象x、y、z，如果x.equals(y) == true且y.equals(z) == true，那么x.equals(z) == true。同样是来自《Effective Java》的一个例子， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public boolean equals(Object o) &#123; if (!(o instanceof Point)) return false; Point p = (Point)o; return p.x == x &amp;&amp; p.y == y; &#125; ... // Remainder omitted&#125; public class ColorPoint extends Point &#123; private final Color color; public ColorPoint(int x, int y, Color color) &#123; super(x, y); this.color = color; &#125; // Broken - violates transitivity! @Override public boolean equals(Object o) &#123; if (!(o instanceof Point)) return false; // If o is a normal Point, do a color-blind comparison if (!(o instanceof ColorPoint)) return o.equals(this); // o is a ColorPoint; do a full comparison return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color; &#125; ... // Remainder omitted&#125; ColorPoint p1 = new ColorPoint(1, 2, Color.RED);Point p2 = new Point(1, 2);ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE); 显然ColorPoint的equals实现违反了传递性，p1.equals(p2) == p2.equals(p3) != p1.equals(p3)。假如Point有两个子类ColorPoint和SmellPoint，colorPoint.equals(smellPoint)将会导致无限递归，最终导致内存耗尽。引用《Effective Java》的说法， There is no way to extend an instantiable class and add a value component while preserving the equals contract, unless you’re willing to forgo the benefits of object-oriented abstraction. 这句话的大意是如果你继承扩展一个类，就没法再保持equals的原则了，除非放弃使用继承。放弃继承？这不是让我们因噎废食嘛，咦，别说，还真能放弃继承，那就是组合，因为本文的重点是equals和hashCode就不展开了。 一致性，对于非null对象x、y，多次调用x.equals(y)返回一致。一致性意味着equals方法不要依赖不可靠的变量，这里“可靠”的意思不光意味着“不该变时不变”，还意味着“想获取时能获取到”，比如java.net.URL的equals实现依赖了ip地址，而网络故障时无法获取ip，这是一个不好的实现。 说了那么多，有人可能会说，哎呀这么多原则顾头不顾尾，都要满足，太难了吧，下面列出实现equals的一些tips，照着做实现起来就易如反掌， 使用==判断是否为null或this，如果是前者返回false，后者就返回true。 使用instanceof检测是否是正确的类型，如果不是直接返回false，如果是，强制转换为正确的类型，然后比较与“逻辑等”相关的变量。 三、hashCode方法hashCode主要用来在Java中哈希数据结构HashMap、HashSet生成哈希值，hashCode的方法签名， 1public native int hashCode(); 默认实现会将对象的内存地址转化为一个整数，因此只有同一个对象hashCode才一样，即使两个equals返回true的对象hashCode也不一样，如果不进行重写。和equals一样，hashCode也需要满足一些原则： 一致性，和equals相关的变量没有变化，hashCode返回值也不能变化。 两个对象equals返回true，hashCode返回值应该相等。由上面得知，hashCode默认实现不满足这一条件，因此任何类如果实现了equals就必须实现hashCode，确保二者的步调一致，下面来看一个反例， 123456789101112131415161718192021222324252627282930public class Person &#123; private int age; private String name; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (obj == this) &#123; return true; &#125; if (obj instanceof Person) &#123; Person that = (Person) obj; return age == that.age &amp;&amp; Objects.equals(name, that.name); &#125; return false; &#125;&#125;Map&lt;Person, Integer&gt; map = new HashMap&lt;&gt;();map.put(new Person(10, \"小明\"), 1);map.get(new Person(10, \"小明\")); 初学者可能觉得最后一条语句会返回1，事实上返回的是null，为什么会这样呢？明明将数据放进去了，而数据却像被黑洞吞噬一样，要解释得从HashMap的数据结构说起，HashMap是由数组和链表组成的一种组合结构，如下图，往里存放时，hashCode决定数组的下标，而equals用于查找值是否已存在，存在的话替换，否则插入；往外取时，先用hashCode找到对应数组下标，然后用equals挨个比较直到链表的尾部，找到返回相应值，找不到返回null。再回过头看刚才的问题，先放进去一个new Person(10, &quot;小明&quot;)，然后取的时候又新建了一个new Person(10, &quot;小明&quot;)，由于没有重写hashCode，这两个对象的hashCode是不一样的，存和取的数组下标也就不一样，自然取不出来了。 两个对象equals返回false，hashCode返回值可以相等，但是如果不等的话，可以改进哈希数据结构的性能。这条原则也可以用HashMap的数据结构解释，举一个极端的例子，假如Person所有对象的hashCode都一样，那么HashMap内部数组的下标都一样，数据就会进到同一张链表里，这张链表比正常情况下要长的多，而遍历链表是一项耗时的工作，性能也就下来了。 那么如何写一个好的hashCode呢？ 声明一个变量int的变量result，将第一个和equals相关的实例变量的hashCode赋值给它。 然后按照下列规则依次计算剩下的实例变量的hashCode值c。 如果是null，设置一个常数，通常为0 如果是原始类型，使用Type.hashCode(f)，Type为它们的装箱类型 如果是数组，如果每一个元素都是相关的，可以使用Arrays.hashCode；否则将相关元素看作独立的变量计算 使用result = 31 * result + c的形式将每个变量的哈希值组合起来，最后返回result。 参考资料：《Effective Java》","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pingao777.github.io/tags/Java/"}]},{"title":"侏罗纪下一部可以叫做We are family","slug":"侏罗纪下一部可以叫做We-are-family","date":"2018-06-25T02:14:51.000Z","updated":"2018-07-07T03:18:50.035Z","comments":true,"path":"2018/06/25/侏罗纪下一部可以叫做We-are-family/","link":"","permalink":"https://pingao777.github.io/2018/06/25/侏罗纪下一部可以叫做We-are-family/","excerpt":"","text":"侏罗纪为了续集越来越无耻了，下一部名字都给你们起好了，就叫We are family，影片一开始，人类和恐龙手牵手围成一圈载歌载舞，一片和谐的景象，或许还可以制定个《恐龙人权保护法》什么的。","categories":[{"name":"生活生活","slug":"生活生活","permalink":"https://pingao777.github.io/categories/生活生活/"}],"tags":[{"name":"侏罗纪公园","slug":"侏罗纪公园","permalink":"https://pingao777.github.io/tags/侏罗纪公园/"}]},{"title":"Maven插件屏蔽第三方包日志的方法","slug":"Maven插件屏蔽第三方包日志的方法","date":"2018-06-01T07:23:04.000Z","updated":"2018-07-07T03:18:50.034Z","comments":true,"path":"2018/06/01/Maven插件屏蔽第三方包日志的方法/","link":"","permalink":"https://pingao777.github.io/2018/06/01/Maven插件屏蔽第三方包日志的方法/","excerpt":"这几天写了一个Maven插件，里面用到了Zookeeper（下面简称ZK），里面打印出了很多“Client environment…”字样的info信息，看着挺闹心，就想着怎么屏蔽掉，让世界清净点。","text":"这几天写了一个Maven插件，里面用到了Zookeeper（下面简称ZK），里面打印出了很多“Client environment…”字样的info信息，看着挺闹心，就想着怎么屏蔽掉，让世界清净点。 刚开始认为ZK使用的log4j，那么在工程里建个resources/log4j.properties，使用log4j.logger.org.apache.zookeeper=WARN的形式来屏蔽掉，结果没起作用。后来又使用log4j.xml的形式，也是不行。再后来又用logback，还是不行，感觉把能想到的方法都试试了，统统不管用，真是郁闷。 将要放弃时，忽然想到既然是在Maven插件里，里面的log系统是不是另有一套呢，一看果然不是log4j，而是simplelogger，按着指导修改了[maven home]\\conf\\logging\\simplelogger.properties，现在有作用了。 因为插件jenkins部署的时候也要使用，如果要修改部署脚本或者挨个修改Maven的配置文件太麻烦，最好能在当前插件里设置，最后试了一下将simplelogger.properties里的配置写到Java系统变量里，果然可以，事情终于圆满解决了，解决方式为添加下面的代码： 1System.setProperty(\"org.slf4j.simpleLogger.log.org.apache.zookeeper\", \"warn\"); 希望能给有类似需求的人一点参考，不得不感叹下Java的日志系统真是杂乱啊！","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://pingao777.github.io/tags/Maven/"},{"name":"日志","slug":"日志","permalink":"https://pingao777.github.io/tags/日志/"}]},{"title":"2018中期计划","slug":"2018中期计划","date":"2018-05-25T07:23:32.000Z","updated":"2018-05-26T11:08:44.250Z","comments":true,"path":"2018/05/25/2018中期计划/","link":"","permalink":"https://pingao777.github.io/2018/05/25/2018中期计划/","excerpt":"虽说伟大的大先知鲁迅曾经说过，要立长志，不要常立志。但是为了将来打脸留个证据，还是要立个字据的。","text":"虽说伟大的大先知鲁迅曾经说过，要立长志，不要常立志。但是为了将来打脸留个证据，还是要立个字据的。 Coursera上Algorithms课程，现在已进行到上半部分第二周。 啃完计算机程序与构造，做一部分习题。 至少每隔一天跑一次步，身体革命本钱。 每周一篇博客，不限制长度。 计划看起来不多，难度较大的是2和3。计算机程序和构造啃了好几次了，都不了了之，和1相比，没有Coursera的时间限制和分数激励，导致自己没有动力，成就感不高，加上有些习题难度较大，比较打击信心，希望这次能把这个硬骨头啃掉。跑步这个事说起来不算难事，难得是坚持下来，特别是一个人。北京这地方，冬天冷，夏天热，遇到刮风下雨，很容易给自己找借口开脱，所以我把标准降低了，允许自己偷下懒。我把朋友圈关闭了，就把博客当成朋友圈吧，每周一篇博客应该没啥问题。 好了，别的不说了，立了计划就得执行，希望年末不打脸。","categories":[{"name":"生活生活","slug":"生活生活","permalink":"https://pingao777.github.io/categories/生活生活/"}],"tags":[{"name":"2018","slug":"2018","permalink":"https://pingao777.github.io/tags/2018/"},{"name":"计划","slug":"计划","permalink":"https://pingao777.github.io/tags/计划/"}]},{"title":"一个初级阶段的五子棋ai","slug":"一个初级阶段的五子棋ai","date":"2017-12-11T08:46:03.000Z","updated":"2018-01-11T14:00:11.204Z","comments":true,"path":"2017/12/11/一个初级阶段的五子棋ai/","link":"","permalink":"https://pingao777.github.io/2017/12/11/一个初级阶段的五子棋ai/","excerpt":"一、前言16年alpha狗接连击败李世石和柯洁后，自己就有个想法，能不能利用机器学习也鼓捣一个类似的五子棋ai？最初的想法是训练一个机器学习模型，喂给它一些棋局，让它自己能够学会落子规则，能够积累优势，最终取得胜利，而且随着下棋盘数的增加，自身的能力可以进一步的提高。但是传统的机器学习需要输入和响应，对于一局棋输入和响应又是什么呢，搜肠刮肚的把自己知道的的几种算法想了一遍，也在网上查了半天，或者模型太复杂，短时间没法掌握相关的知识，或者模型计算代价太高，动辄训练个几天，所谓远水解不了近渴，最好的能一个周末能整出一个初级的ai，能打败我就行，以后有时间功能可以慢慢加，这也是标题的由来。","text":"一、前言16年alpha狗接连击败李世石和柯洁后，自己就有个想法，能不能利用机器学习也鼓捣一个类似的五子棋ai？最初的想法是训练一个机器学习模型，喂给它一些棋局，让它自己能够学会落子规则，能够积累优势，最终取得胜利，而且随着下棋盘数的增加，自身的能力可以进一步的提高。但是传统的机器学习需要输入和响应，对于一局棋输入和响应又是什么呢，搜肠刮肚的把自己知道的的几种算法想了一遍，也在网上查了半天，或者模型太复杂，短时间没法掌握相关的知识，或者模型计算代价太高，动辄训练个几天，所谓远水解不了近渴，最好的能一个周末能整出一个初级的ai，能打败我就行，以后有时间功能可以慢慢加，这也是标题的由来。 二、Minimax算法对于这种回合制的游戏，传统的方法就是利用minimax算法，那么什么是minimax算法呢，说白了，就是和人在脑子里模拟往下走几步一样，minimax算法也是模拟往下走棋，轮到自己时选自己最有利的，即max，轮到对方时选自己最不利的，即min，直到某一条件终止，然后选择一条对自己最有利的路径。由此可以看到，如果计算资源足够，计算机是可以找到一条可以使己方胜利的路径，但是事实上这是不可能的，以15X15的五子棋为例，大约有225!种可能的走法，想穷举出这么多种可能性，以目前的计算能力是达不到的，所以一般的做法是往下模拟走一定的步数，然后选择一条最优的。 三、评估函数由算法描述，必须有一种方法对当前的局势进行衡量，通常的方法就是使用评估函数。评估函数可以根据当前局势给出一个分数，使局势成为可量化的数值。具体到五子棋就是统计棋局中的活三、活四等模式并给予一定的分数然后将总的分数相加，具体请参考代码。 四、优化1、Alpha-beta剪枝单纯的minimax算法复杂度是非常高的，从算法的描述，算法的复杂度应该是$O(b^d)$,d是往后走的步数，b是每一步棋可选的位置。以五子棋为例，模拟走5步大约是$225^5=576650390625$，显然这个数目还是太大，所以需要引进alpha-beta剪枝。这种算法就是用一个变量alpha保存着max一方可以得到的最优值，beta保存着min一方只允许max一方获得的最优值，当beta小于等于alpha时其他的情况就不用再看了，因为最优值的上限就是beta。 2、减少可选的落子位置下过五子棋的可能都知道，如果落子的位置离己方和对方的棋子太远是没有意义的，因此我把这个距离限制为2，这样把原来b从225减少到了20~30，这个优化是很可观的。 3、历史启发alpha-beta剪枝的效率是和下一步棋的顺序密切相关，如果最合适的那一步棋总是先计算那么算法的效率可以达到$O(b^\\sqrt{d})$，这就相当于同样的时间原来只能往后推算5步，现在可以推算10步，而如果顺序不当，效率和没剪枝的minimax没什么两样。历史启发的原理就是记录那些发生剪枝次数最多的位置，以及得分的极值，赋予它们一定的值，以此来排序。 最终的核心代码如下， 123456789101112131415161718192021222324252627282930313233343536373839private int alphaBeta(Board board, int depth, int alpha, int beta, Player player) &#123; if (board.status().isGameOver() || depth &lt;= 0) &#123; return board.evaluate(this, this.depth - depth); &#125; Board.Pos bestPos = null; int v = (this == player) ? Integer.MIN_VALUE : Integer.MAX_VALUE; List&lt;Board.Pos&gt; childPos = sortChildPos(board); for (Board.Pos pos : childPos) &#123; Board bd = new Board(board); bd.mark(pos, player); int w = alphaBeta(bd, depth - 1, alpha, beta, bd.getEnemy(player)); if (this == player) &#123; if (v &lt; w) &#123; v = w; bestPos = pos; if (depth == this.depth) &#123; this.best = new Move(v, pos); &#125; &#125; alpha = Integer.max(alpha, w); &#125; else &#123; if (v &gt; w) &#123; v = w; bestPos = pos; &#125; beta = Integer.min(beta, w); &#125; if (beta &lt;= alpha) &#123; this.history[pos.getRow()][pos.getCol()] += 2 &lt;&lt; depth; break; &#125; &#125; if (bestPos != null) &#123; this.history[bestPos.getRow()][bestPos.getCol()] += 2 &lt;&lt; depth; &#125; return v;&#125; 五、战力如何首先是人机对战，当推算的步数达到4步时，我是没赢过，但是这并不能说明它的战力有多强，只能说明我的水平很臭，但是我的初步目标达到了；其次我让两个同等级的电脑对战50局，战绩如下， 等级（步数） 先手赢 后手赢 平局 1 40 10 0 2 16 12 22 3 27 18 5 似乎印证了先手的胜率高一点。 六、下一步工作 可以看到ai的战力是和评估函数密切相关的，获取一个比较好的评估函数是一个优化的方向。 目前ai不能自我学习，如何让ai自我学习，并逐步变强是另一个方向，这也是重点方向。 如果想在我的代码上继续前进，请戳这里，下图是一局电脑对战的动图。 参考资料： Minimax Alpha-beta pruning Killer_heuristic","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"五子棋","slug":"五子棋","permalink":"https://pingao777.github.io/tags/五子棋/"},{"name":"minimax","slug":"minimax","permalink":"https://pingao777.github.io/tags/minimax/"},{"name":"alpha-beta","slug":"alpha-beta","permalink":"https://pingao777.github.io/tags/alpha-beta/"}]},{"title":"浅谈Java泛型","slug":"浅谈Java泛型","date":"2017-11-28T03:03:16.000Z","updated":"2018-08-04T03:53:53.133Z","comments":true,"path":"2017/11/28/浅谈Java泛型/","link":"","permalink":"https://pingao777.github.io/2017/11/28/浅谈Java泛型/","excerpt":"相信每个Java程序员对泛型都不陌生，不少人也用过泛型，但是泛型中确实有些点容易让人迷惑，下面我结合自己的使用经历和理解谈谈对泛型的认识，不求面面俱到，但求切中要害。","text":"相信每个Java程序员对泛型都不陌生，不少人也用过泛型，但是泛型中确实有些点容易让人迷惑，下面我结合自己的使用经历和理解谈谈对泛型的认识，不求面面俱到，但求切中要害。 一、泛型是什么引用Java文档的解释， A generic type is a generic class or interface that is parameterized over types. 大致的意思就是类型经过参数化的类或接口。 二、为什么要泛型在泛型出现之前你要定义一个存储水果类的列表，你只能这样写， 1234List fruits = new ArrayList();Elephant e = new Elephant();fruits.add(e);Fruit f = (Fruit) fruits.get(0); 虽然定义了一个名叫fruits的列表，但是你里面存大象也没人管你，只有在运行时你试图将列表的元素赋值给一个水果时才会报错。为了更早的发现这种错误，Java在5.0引入了泛型机制(Generics)。有了泛型上面的程序就可以这么写， 123List&lt;Fruit&gt; fruits = new ArrayList&lt;Fruit&gt;();Elephant e = new Elephant();fruits.add(e); // Compile error 这样当你往水果的列表里塞一个大象时编译器就会报错，而不用等到运行时，而且也避免了显式的转型。 三、泛型分类从程序的层次上，泛型分为泛型类和泛型方法。比如Java中的ArrayList类就是一个泛型类， 1public class ArrayList&lt;E&gt; 而集合工具类Collections中的emptyList方法就是一个泛型方法， 123public static final &lt;T&gt; List&lt;T&gt; emptyList() &#123; return (List&lt;T&gt;) EMPTY_LIST;&#125; 到这里其实没什么要说的。 四、更进一步1、通配符?通配符代表的意思应该是“某个或某些具体但不确定的类型”，首先具体的是指将来要用某个具体的类来替换通配符，其次不确定是指当前还确定不了是哪种具体类型。 2、边界边界也就是某种类型的子类型或父类型，即super定义的下界和extends定义的上界。 3、类型擦除如果用一句话解释就是用不用泛型编译后的代码是一样的，更详细更准确的解释是由于泛型是在Java 5.0引入的，为了兼容老版本的Java，编译器会将泛型参数替换为它的边界（上界），如果有多个边界，只保留最左边的，如果没有边界替换为Object，最终保留下来的只有正常的类、接口和方法。 123456789public class GeneralTest&lt;T extends Comparable&lt;T&gt; &amp; Iterable&lt;T&gt; &amp; Serializable&gt; &#123; void test1(T t) &#123; ... &#125; &lt;E&gt; void test2(E e) &#123; ... &#125;&#125; 编译后生成的代码为， 12345void test1(T); descriptor: (Ljava/lang/Comparable;)V&lt;E&gt; void test2(E); descriptor: (Ljava/lang/Object;)V 可以看到T的边界有三个Comparable&lt;T&gt; &amp; Iterable&lt;T&gt; &amp; Serializable，编译后只保留了Comparable，而且Comparable的泛型&lt;T&gt;也去掉了；test2中的E没有边界，它直接被替换为了Object，而且test2作为泛型方法编译后也没有任何泛型的信息。 4、替换原则一个类型的变量可以接受子类型的变量，一个据有某种参数的方法可以在参数的子类型上调用。这个原则几乎是面向对象编程的基础，它可以让我们这么写代码， 12Fruit a = new Apple();List l = new ArrayList(); 可以把一个“苹果”赋值给“水果”，可以把ArrayList赋值给List。 5、PECS原则也就是所谓的Producer Extends, Consumer Super原则，作为生产者时使用extends，作为消费者时使用super，这条原则其实是替换原则的推论。 12345List&lt;??&gt; list = Arrays.asList(1, 1.3, 5L);Number i = list.get(0);Map&lt;String, ??r&gt; map = new HashMap&lt;&gt;();map.put(\"212\", 1); 比如你想要从list中取出的数据可以赋值给一个Number，根据替换原则，“一个类型的变量可以接受子类型的变量”，你就得定义list中的类型都是Number的子类型。那么如何表示一个Number的子类型呢，因为extends在Java中本来就表示继承的意思，所以很自然的想法就是? extends Number，这恰恰就是正确答案。 再比如，你想在map值里存储各种数字，根据替换原则，“一个据有某种参数的方法可以在参数的子类型上调用”，也就是你想要put方法适用在各种数字类型上，“各种数字类型”是这里的“子类型”，所以你需要定义map的值是“各种数字类型”的父类型才可以，表示父类Java中同样有个关键字super，所以你可能猜想? super Number表示的就是这个意思，没错，答案就是这个。 你可以看到，在两种情况下，确定泛型是替换原则中的子类型还是父类型是关键中的关键。这恰恰就是PECS原则的内容，即作为生产者，将泛型传递给别的变量时，使用extends；作为消费者，将别的变量传递给泛型时，使用super。 6、是泛型方法还是通配符在泛型中，经常面临的一个抉择就是是使用泛型方法还是使用通配符。比如下面的方法， 1234interface Collection&lt;E&gt; &#123; public boolean containsAll(Collection&lt;?&gt; c); public boolean addAll(Collection&lt;? extends E&gt; c);&#125; 如果写成泛型方法， 1234interface Collection&lt;E&gt; &#123; public &lt;T&gt; boolean containsAll(Collection&lt;T&gt; c); public &lt;T extends E&gt; boolean addAll(Collection&lt;T&gt; c);&#125; 可以看到类型参数T在方法中只使用了一次，和别的类型参数也没有关系，和函数返回值也没有关系，所以T在这里就显得有点多余。 再看另一个例子， 1234class Collections &#123; public static &lt;T&gt; void copy(List&lt;T&gt; dest, List&lt;? extends T&gt; src) &#123; ...&#125; 这里的类型参数T就是必须的了，它表明了源列表和目标列表元素的依赖关系，如果没有一个具体的类型参数，这种依赖没法表述。但是如果你写成下面这个样子，就有点画蛇添足了。 1234class Collections &#123; public static &lt;T, S extends T&gt; void copy(List&lt;T&gt; dest, List&lt;S&gt; src) &#123; ...&#125; 可以说，原则就是尽可能的使用通配符，因为它更加精炼，当通配符达不到目的的时候再使用具体的类型参数。 五、最后说几句Java的泛型远不止这些内容，文中只是我个人使用泛型中比较困惑的点，可能有些地方理解的也不是那么透彻和准确，还请不吝赐教。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pingao777.github.io/tags/Java/"},{"name":"泛型","slug":"泛型","permalink":"https://pingao777.github.io/tags/泛型/"}]},{"title":"疏而不漏：随机森林","slug":"疏而不漏：随机森林","date":"2017-11-18T01:31:53.000Z","updated":"2018-07-29T02:23:09.394Z","comments":true,"path":"2017/11/18/疏而不漏：随机森林/","link":"","permalink":"https://pingao777.github.io/2017/11/18/疏而不漏：随机森林/","excerpt":"一、概述在三生万物：决策树中我们提到当决策树和装袋法(Bagging)和提升法(Boosting)结合后会成为更强大的算法，那么今天就介绍一种名叫随机森林(Random Forest)的算法，它是将决策树、装袋法以及随机特征选取结合后衍生出的一种增强型的树算法。","text":"一、概述在三生万物：决策树中我们提到当决策树和装袋法(Bagging)和提升法(Boosting)结合后会成为更强大的算法，那么今天就介绍一种名叫随机森林(Random Forest)的算法，它是将决策树、装袋法以及随机特征选取结合后衍生出的一种增强型的树算法。 它有如下特点： 运行起来非常有效率，可以很容易的并行化 可以无删减的处理成千上万的输入变量，并可以评估变量的重要性 不用将数据专门分为训练集和测试集，随机森林构造完就可以得到近似的测试误差 能够很有效的处理缺失值 可以有效的分离出离群点 对过拟合有很强的抗性 还可以用于非监督式学习…… 看到随机森林有这么多的优点，你是不是心动了呢？那么接下来和我一起来认识一下它吧！ 二、算法1、基本步骤上文提到随机森林不是一种全新的算法，而是几种算法的强强联合。随机森林的构建一般有这么几个步骤： 首先确定树的数量(Tree Size)，而每个树的训练数据通过有放回的抽取原始数据。由于是有放回的抽样，原始数据中约有1/3的量没有被抽到，这些数据称为袋外数据(OOB, Out Of Bag) 树的树训练数据有了，接下来就该训练了，与决策树不同，这里的树在构建的时候，每一次分裂都要进行随机特征选取，也就是在特征的随机子空间进行分裂，比如一个数据集有5个特征，每次分裂有放回的随机取3(Feature Count)个 到这里，所有的树都应该构造完成了，森林也就有了，那么怎么对响应值进行预测呢？这就要依靠集体的智慧了，每个树都有一个预测值，对于分类问题，取频率最高的那个值；对于回归问题，取所有值的平均 2、袋外误差(OOB Error)算法作者说OOB Error可以作为测试误差的无偏估计，也就是计算出OOB Error就可以得到测试误差，不用专门把数据专门拿出来一部分作为测试集。下面举例说明如何计算OOB Error，比如我们要在一个有7条数据的数据集上构建一个5棵树的随机森林，那么在步骤1的时候会出现下面这样一张表: 数据编号 树1 树2 树3 树4 树5 1 X √ √ X √ 2 √ X X X X 3 √ √ √ √ √ 4 √ √ X √ √ 5 √ X √ √ X 6 √ √ X √ √ 7 X √ √ √ √ 表里的X代表没有选中，√代表选中。对于树1，数据1和7就是OOB，对于树2，数据2和5就是OOB，其他以此类推，那么数据1的预测值由树1和树4决定，数据2的预测值由树2-5来决定，以这样的方式计算出每个数据的预测值，进而得到误差值，即OOB Error。 3、变量重要性(Variable Importance)假设我们已经计算出了OOB Error，一个变量的重要性可以这么计算，将变量打散，然后重新计算打散后的OOB Error，取打散前后OOB Error差值的绝对值，越大代表这个变量越重要。变量重要性在实践过程中非常好用，比如在一个10000维度的数据集选出100个最重要的变量，即数据的降维。 4、相似性(Proximities)相似性由相似性矩阵体现，相似性矩阵是一个NxN的对称矩阵，它的计算方式如下，如果数据n和数据p同属于同一颗树的同一个叶子节点，那么相似性加1，即proximities[n,p]和proximities[p,n]均加1，最后除以树的数目进行标准化。 5、离群点(Outliers)有了相似性，也就可以计算离群点了。它基于这样的假设，如果一条数据和其他数据都不相似或者相似性很低，那么这条数据很可能是个离群点。这和人很类似阿，如果一个人不合群，那么他肯定是比较孤立的。不过在我实际操作的过程中，即使计算出了潜在的离群点，如何确定它真的是不是不是那么容易。 具体的计算过程如下，定义类别为j的数据n的平均相似性为： $$\\bar{P}(n) = \\sum_{cl(k)=j}prox^2(n,k)$$ 得到非相似性： $$Dissimilarity(n) = nsample(j) / \\bar{P}(n)$$ 然后在各自的类别中标准化，得到最终的Dissimilarity，算法作者给出的经验值是如果一条数据的Dissimilarity&gt;10，那么可能是一个潜在的离群点。 6、缺失值对于缺失值，传统的方法就是数值变量取均值，分组变量取最多的那一类。而随机森林处理缺失值另有一套：先使用一个不太准确的初始值替换缺失值，然后计算数据间的相似性，数值变量取同一类别非缺失值的相似性加权平均；分组变量取频率最高的值，频率要经过相似性加权，然后重复这一过程4-6次。 三、案例在决策树代码的基础上稍加改动就得到了随机森林，下面检验一下新算法的能力。 1、在三生万物：决策树里我尝试使用花萼长度(Sepal.Length)和花萼宽度(Sepal.Width)这两个变量来预测鸢尾花的种类(Species)，这里用随机森林试一试。 首先来看下不同数目的树对分类的影响，下图的分类边界(Decision Boundary)，使用的Node Size为1，特征数Feature Count也为1, 可以看到，与决策树相比，随机森林对过拟合(Overfit)有着很强的抗性，且随着树的数目增多过拟合越来越少。但是，另一方面也要看到尽管对过拟合很强的抗性，还是可以看到过拟合的影子，即便我们已经用了1000棵树。所以，还是要为随机森林选择一个合适的Node Size, 从上面的第一张图，可以看到Node Size从0～100增加时，OOB Error先降后增，且在Node Size为15时达到最低。从第二张图可以看到随机森林分类边界的变化过程，先是轻微的过拟合继而最合适的边界最后严重的欠拟合。第三张图是最合适的分类边界，尽管和决策树一样，预测的错误率都为0.2左右，但是和决策树的分类边界相比，随机森林的边界更平滑。 2、北京二手房 为了和决策树作对比，我也用随机森林来预测下房价(price)，也是使用区域(area)、是否学区(school)、是否有地铁(subway)、总价(num)这四个变量，使用的参数为树的数目TS=100，特征数Feature Count=4，节点数目Node Size=5，得到的结果如下， 12345678$r2[1] 0.7014904$importance area 0.48257784num 0.37338239school 0.08469551subway 0.04547572 袋外决策系数R2为0.7，使用模型预测所有房屋价格的决策系数为0.74，比决策树的0.7高了4个百分点，大家不要小看了这4个百分点，在机器学习中哪怕1个百分点都要付出很大的努力。况且，我在这里并没有使用交叉验证获取最佳的参数，只是凭经验选取。另外模型还给出了预测房价各个变量的重要性，可以看到决定房价最重要的就是房子所在的区。 接下来是个分类问题，使用小区(region)、户型(zone)、面积(meters)、朝向(direction)、区域(con)、楼层(floor)、房龄(year)、学区(school)、地铁(subway)、税(tax)、总价(num)、单价(price)来预测区(area)。随机从29790中抽取了10000条数据构造100颗树的随机森林，构建一个100棵树的森林，OOB Error和变量重要性如下， 12345678910111213141516$oob_error[1] 0.1241$importancecon 0.5454price 0.3717school 0.1132year 0.0556subway 0.0490region 0.0168direction 0.0163meters 0.0043num 0.0040zone 0.0026floor 0.0007tax 0.0007 OOB Error约为0.12，使用得到的随机森林模型预测29790条房源的区域，误差约为0.08，两者还是比较接近的。不出所料，片区(con)的重要性最高，另外房价(price)、是否学区(school)对房子区域的重要性也决非浪得虚名。 上文提到，随机森林可以作为降维的工具，我从中选择前6个重要的变量重新构建一个随机森林，OOB Error和变量重要性如下， 12345678910$oob_error[1] 0.11$importancecon 0.5638price 0.3812school 0.1140year 0.0831subway 0.0490region 0.0254 可以看到，使用6个变量的OOB Error与使用全部12个变量的OOB Error不相上下。 下面看看有没有潜在的离群点，下图是每套房子的Dissimilarity， 有两套房子的Dissimilarity&gt;10，看看是什么房子， 123region zone meters direction con floor year school subway tax num price area福成公寓A 3室1厅 135 南北 燕郊城区二手房 低楼层 2004 无学区 无地铁 非免税 405 30000 燕郊达观别墅 4室2厅 270 南北 燕郊城区二手房 低楼层 2009 无学区 无地铁 非免税 1600 59260 燕郊 初步看来，这两套房子的总价(num)和价格(price)有点高，是不是这一点让它们鹤立鸡群呢？ 四、总结本文简单介绍了随机森林的特点及算法，并简单分析了iris和北京二手房两个数据集。本文只是抛砖引玉，其实随机森林的还有一些其他的特性，大家可以多多去发掘。 参考资料： Random Forests Leo Breiman and Adele Cutler Random forest","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://pingao777.github.io/tags/机器学习/"},{"name":"随机森林","slug":"随机森林","permalink":"https://pingao777.github.io/tags/随机森林/"}]},{"title":"简洁高效的Boyer-Moore算法","slug":"简洁高效的Boyer-Moore算法","date":"2017-11-16T13:52:42.000Z","updated":"2018-01-11T14:00:11.204Z","comments":true,"path":"2017/11/16/简洁高效的Boyer-Moore算法/","link":"","permalink":"https://pingao777.github.io/2017/11/16/简洁高效的Boyer-Moore算法/","excerpt":"子串检索有着很广泛的应用，例如在文档软件中查找关键词，网站过滤敏感词，生物学家查找某种模式的基因组序列等等，很多人听说过著名的KMP算法，Boyer-Moore算法做到的更多，有迹象表明在某些情况下效率是前者的3-5倍，且实现起来更加简单，符合我简单高效的原则。","text":"子串检索有着很广泛的应用，例如在文档软件中查找关键词，网站过滤敏感词，生物学家查找某种模式的基因组序列等等，很多人听说过著名的KMP算法，Boyer-Moore算法做到的更多，有迹象表明在某些情况下效率是前者的3-5倍，且实现起来更加简单，符合我简单高效的原则。 下面先抛开算法不谈，如果让你在ABCSAKDFFEHHJDDEFKLD中查找DDEFK，你会怎么做？ 12ABCSAKDFFEHHJDDEFKLDDDEFK 最直接的就是暴力检索法，挨个比较文本和模式的每个字符，成功就继续比较模式字符的下一个，否则将模式往右移动一位，继续上述过程，直到文本的结尾或者搜索成功，通常情况下效率还可以，因为对于大部分文档往往只需要比较模式中的一两个字符，就会有非匹配字符，因此模式可以快速的向右移动，整体运行时间接近线性。java示例代码为 12345678910111213int M = pat.length();int N = txt.length();for(int i = 0; i &lt;= N - M; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (txt.charAt(i + j) != pat.charAt(j)) &#123; break; &#125; if (j == M - 1) &#123; return i; &#125; &#125;&#125;return -1; 而本文的主角BM算法可谓别出心裁，它从后往前匹配模式的每一个字符，看看BM算法是如何处理上面的例子的，我们用i表示文本的起始位置，j表示模式中待匹配字符的位置。 第一步，i=0，j=4，A与K匹配失败，没有必要再往前匹配，i往后移动4+1=5个字符，因为小于这个数字，A都会与模式中的某个字符重叠，而模式中没有这个字符，无论如何都会失败。 1234i=0ABCSAKDFFEFKJDDEFKLDDDEFK j=4 第二步，i=5，j=4，E与K匹配失败，i需要再次往后移动，这次需要移动几个字符呢，答案是2，这样会将模式中最右边的E与文本中E对齐，小于这个数，文本中E会与模式E右边的字符重叠，这些字符中没有E，因此不可能成功。 1234 i=5ABCSAKDFFEFKJDDEFKLD DDEFK j=4 第三步，i=7，j=4，这次匹配成功了，j减一j=3，又成功了，j再减一j=2，又成功了，j再减一j=1，这次F与D没有匹配成功，这次i要移动多少呢，F在文本和模式中都出现了，但是模式中的F已经匹配过了，我们不想让i回退，只能让i简单的加1。 1234567 i=7ABCSAKDFFEFKJDDEFKLD DDEFK j=4 j=3 j=2 j=1 第四步，i=8，j=4，同样J和K匹配失败，且J不在模式字符串中，同第一步，我们将i移动4+1=5个字符。 1234 i=8ABCSAKDFFEFKJDDEFKLD DDEFK j=4 第五步，i=13，k=4，当j=4…0时，每个字符都匹配成功，成功检索到模式，将i=13返回，或者将i的值存储起来继续往后搜索，如果想得到模式的所有位置。 12345678 i=13ABCSAKDFFEFKJDDEFKLD DDEFK j=4 j=3 j=2 j=1 j=0 这样i移动5次，总共比较了12个字符，就完成了查找。 总结一下，BM算法的策略是从后往前匹配模式中的每个字符，直到文本中出现一个不匹配的字符txt.charAt(i+j)或者检索成功返回i。与暴力检索不同的是，当匹配失败时，BM算法不会按部就班的移动i，它首先会构造一个right数组，数组中存储的是字符集中每个字符在模式中最右边的位置，如果字符不在模式中设为-1，比如上面的例子， 1234right['D']=1right['E']=2 right['F']=3 right['K']=4 下面是可能出现的三种情形， 当非匹配字符txt.charAt(i+j)不在模式中时，就像上面第一步那样，i需要右移j+1个字符，否则非匹配字符就会与模式字符串的某个字符重叠。 当非匹配字符txt.charAt(i+j)是模式中一员时，如上第二步那样，i需要右移j-right[txt.charAt(i+j)]，小于这个步数也会发生重叠。 第三种情形其实是第二种情形的补充，虽然非匹配字符txt.charAt(i+j)在模式中，但是已经比较过，这样j-right[txt.charAt(i+j)] &lt; 1，这种情形下只让i简单的右移1位。 这是一段示例代码， 1234567891011121314151617181920public List&lt;Integer&gt; search(String txt) &#123; int N = txt.length(); int M = pat.length(); List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0, skip = 0; i &lt;= N - M; i += skip) &#123; for (int j = M - 1; j &gt;= 0; j--) &#123; if (pat.charAt(j) != txt.charAt(i + j)) &#123; skip = j - right[txt.charAt(i + j)]; if (skip &lt; 1) &#123;skip = 1;&#125; break; &#125; if (j == 0) &#123; pos.add(i); skip = M; break; &#125; &#125; &#125; return pos;&#125; 上面的代码会找出文本中模式出现的所有位置，在大部分情况下，上面这段代码的运行效率为$O(N/M)$，但是，当文本中包括大量的重复字符时，搜索的效率为$O(NM)$，请看下面的例子， 1234567891011121314151617181920txt length: 20pat length: 5--------------------BBBBBBBBBBBBBBBBBBBBABBBB #0 0 ABBBB #1 5 ABBBB #2 10 ABBBB #3 15 ABBBB #4 20 ABBBB #5 25 ABBBB #6 30 ABBBB #7 35 ABBBB #8 40 ABBBB #9 45 ABBBB #10 50 ABBBB #11 55 ABBBB #12 60 ABBBB #13 65 ABBBB #14 70 ABBBB #15 75 每一步后面有两个数字，第一个数字表示i移动的次数，后一个表示比较的字符数，如上所示，这个例子i移动了15次，总共比较了75个字符，接近于20*5，效率为$O(NM)$。这不是我们想看到的，为了应对这种情形需要引进另一个数组delta，delta数组中存储的是文本中每个字符最后出现的地方，默认值为模式的长度，这样当遇到非匹配字符txt.charAt(j)时至少delta[pat.charAt(j)]-j这一段是不可能匹配的，因为在文本中这一段没有出现pat.charAt(j)，比较的时候就有了两个移动距离，取其大者。下面是新的代码， 1234567891011121314151617181920212223242526public List&lt;Integer&gt; search(String txt) &#123; int N = txt.length(); int M = pat.length(); List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0, skip = 0; i &lt;= N - M; i += skip) &#123; for (int j = M - 1; j &gt;= 0; j--) &#123; char c1 = txt.charAt(i + j); char c2 = pat.charAt(j); delta[c1] = j; if (c1 != c2) &#123; int skip1 = j - right[c1]; int skip2 = delta[c2] - j; skip = Math.max(skip1, skip2); if (skip &lt; 1) &#123;skip = 1;&#125; break; &#125; if (j == 0) &#123; pos.add(i); skip = M; resetDelta(); break; &#125; &#125; &#125; return pos;&#125; 每次匹配成功，需要重置delta数组，即上面resetDelta()。将这段代码与上面那一版进行对比，看看有哪些区别。完整代码在这里，用这一段代码再运行上面的例子， 12345678txt length: 20pat length: 5--------------------BBBBBBBBBBBBBBBBBBBBABBBB #0 0 ABBBB #1 5 ABBBB #2 10 ABBBB #3 15 这次好多了，i移动了3次，只比较了15个字符，就完成了整个检索，算法复杂度基本为线性。好了，算法分析与证明不是那么有意思，最后就以我做的两个实验来结束吧。 横轴为文本长度，纵轴表示比较的字符数，文本和模式从26个大写字母随机生成。可以看到，对于长度为10的模式，BM算法复杂度大约为$O(N/M)$，暴力检索为$O(N)$。 与上图不同，这幅图的文本和模式是从4个大写字母随机选择，因此重复率要高的多。可以看到，对于重复率很高的字符串，BM算法效率也能达到$O(N)$，而暴力检索接近$O(NM)$。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://pingao777.github.io/tags/算法/"}]},{"title":"当Python和R遇上北京二手房（下）","slug":"当Python和R遇上北京二手房（下）","date":"2017-11-16T13:50:42.000Z","updated":"2018-07-29T11:17:36.891Z","comments":true,"path":"2017/11/16/当Python和R遇上北京二手房（下）/","link":"","permalink":"https://pingao777.github.io/2017/11/16/当Python和R遇上北京二手房（下）/","excerpt":"四、各区情况作为买房者第一步就是看房选房，那么各区的情况是怎样的呢？下面从买房者比较注重的五个方面横向对比一下。","text":"四、各区情况作为买房者第一步就是看房选房，那么各区的情况是怎样的呢？下面从买房者比较注重的五个方面横向对比一下。 1.各区总价 （图中红点为本区域的均值） 果然不出所料，西城、东城、海淀、朝阳四区均值和中位数均在前列，且数据区间分布比较广，而一些新兴的郊区如房山、门头沟、燕郊总价则较为集中，大概是因为房子是同一时期建设，功能需求也比较单一的缘故。 另外我注意到，各区的总价均值均不同程度的偏离中位点，城区偏离较大，郊区偏离较小，是不是因为城区房子需求多样，一些别墅豪宅拉高了均值？值得注意是顺义的均值超过了上四分位数，是不是顺义有较大比例的高档房产呢？ 下面换个角度，以二维直方图来展示下 由于各区二手房总量差异较大，这里的颜色代表的是总价区间在本区的占比，从这张图上可以看到西城、东城、海淀、朝阳、顺义确实有一定数量的千万房产。 2.各区单价 这张图很有意思，能发现很多东西。 第一，市区的房价高，郊区房价低，这傻子都知道，呵呵。第一梯队东西城、海淀50%的房子单价都在5万以上，想买这些地方的房子，看看腰包鼓不鼓，第二梯队朝阳、丰台、石景山大部分房子都在3万以上，第三梯队剩下的区房价大部分都在2万5以下，燕郊最低，基本上在1万2左右； 第二，市区的房价范围广，均值偏离中位数幅度大，比如东西城，应该是这两区一些高质量的学区房导致。 3.各区面积 （图中红点为本区域的均值） 可以看出一个趋势，郊区的房子要比市区的房子大。例如东西城面积中位数在75平米左右，而昌平、亦庄等均在100平米左右。还有就是市区房子面积范围较大，而郊区可能起步较晚，基本上建筑年代都在同一时期，房子的面积也较为单一。 顺义200平米的房子比例不少，再结合其千万以上的总价，看来顺义卧虎藏龙。 4.各区建筑年代 这张图上印证了上面的猜测，昌平、房山、亦庄、通州、燕郊等郊区房子建筑年代较为集中，尤其是燕郊，基本上都是2010年左右的房子，而最近因市政府东迁而大火的通州75%的房子是2000年后。而东西城、海淀等区域则是各个年代的房子都有。 从这张图似乎更能明显的看出，昌平、通州、亦庄、燕郊都有一些颜色较深的色块。大兴、房山、顺义、亦庄、燕郊均有超过20%的2010年后的房子，东城、石景山、西城则有20%的90年以前的老房子。 5.各区学区 再来看一下喜闻乐见的学区房，不出所料，海淀区的学区房最多，朝阳区学区次之。由于没有对学区的质量进行分类，东西城这两区虽然数量不如前两者，但是从质量上这两区应该是不言而喻的。 上面，从5个方面分区域做了一下比较，总结一下，喜欢新房的多去昌平通州等区走走，想要学区房的海淀、朝阳是你的选择，如果你只想最贵的，那么东城、西城是你的不二之选，如果你是土豪，顺义是个好去处。 五、一些有意思的事1.房子是不是随着时代的发展越来越大了呢？ 因为大部分房子都在1985 ~ 2015这个时间段，我将视角集中在这个时间段。图中红线为均值，蓝线为中位数。 从图上可以很清楚的看出在1995年房屋面积有一个很明显的上扬，到2000年左右保持平稳，从之前的60平到100平，从2005年开始又有小幅度的下降，难道是刚开始起高了？还有一点是，1995年前的房子，均值和中位数基本持平，95年之后均值大于中位数10个平方左右，是否可以得出以前我们都是无产阶级，现在确实有一部分先富起来了哈哈。 看来，随着时代的发展房屋面积确实有了不小的增长，希望随着时代的进步，人人都能住得起大房子。 2.学区房房价要比非学区贵多少呢？ 数据显示，各个区学区房房价确实要比非学区贵一些，这个差距大概在5000 ~ 15000左右,石景山、西城这个差距较大，都在10000以上，昌平和海淀稍微低些，大约每平方相差8,9千，朝阳东城相差的不多，丰台通州几乎持平。 3.那些地方房价最贵？ 这些房价最贵的地方除万柳其余都在二环以里，基本上分布在北京最中心的地带，果然寸土寸金啊。 4.哪些地方千万豪宅最多？ 而一些豪宅就不一样了，除金融街其余都在三环以外。这也难怪，三环里面就那么点地方，早就占满了，想要豪宅就得往郊区盖，比如中央别墅区、西北旺都在五环以外。 5.哪些地方学区最多呢？ 学区最多的十个区域，朝阳四个，海淀两个，西城两个，东城两个。 六、总结通过两篇文章，我尝试对北京二手房的一些特点进行了分析，分析很初级，基本上就是统计个数量或者比例，对于一些高大上的统计分析方法也在学习当中，等学的差不多了，再补上。 说句题外话，即便是最简单的数据展示和统计分析也能让人学到不少东西，当你着手开始做的时候，你会碰到各种各样的问题，小到图形的字体怎么调整、图形的legend如何改变，大到一些统计方法的实用、数据的处理方法等，鼓励大家根据自己的兴趣，自己动手整一个小的数据集，在这个基础上有目的的进行学习，有道是，当你上路了，你就已经进步了。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"R","slug":"R","permalink":"https://pingao777.github.io/tags/R/"},{"name":"Python","slug":"Python","permalink":"https://pingao777.github.io/tags/Python/"},{"name":"统计","slug":"统计","permalink":"https://pingao777.github.io/tags/统计/"}]},{"title":"当Python和R遇上北京二手房（上）","slug":"当Python和R遇上北京二手房（上）","date":"2017-11-16T13:48:19.000Z","updated":"2018-07-29T11:07:32.457Z","comments":true,"path":"2017/11/16/当Python和R遇上北京二手房（上）/","link":"","permalink":"https://pingao777.github.io/2017/11/16/当Python和R遇上北京二手房（上）/","excerpt":"最近忙活了一阵子，终于把房子的事情落实了，俗话说饱暖思淫欲，某天突发奇想能不能利用手头上的一些工具对北京的二手房数据捣鼓一下，看看能不能有一些有意思的发现？想到以前有点python经验，正巧最近也在看R，正好借此机会巩固一下，齐活，走起！","text":"最近忙活了一阵子，终于把房子的事情落实了，俗话说饱暖思淫欲，某天突发奇想能不能利用手头上的一些工具对北京的二手房数据捣鼓一下，看看能不能有一些有意思的发现？想到以前有点python经验，正巧最近也在看R，正好借此机会巩固一下，齐活，走起！ 一、数据准备看了下各大房产网站，从数据的量级、真实性、即时性等方面对比了下，有的数据挺多，但是数据真实性不高，上面既有房主的帖子，也有中介的帖子；有的真实性不错，但是房源太少，综合对比下来，最终选择了某家网。 有了数据源，用Python写了一个爬虫，从网站上随机爬取了30000条房源数据。有人可能说数据太少了，少就少吧，这里只是想起到一个抛砖引玉的作用。 二、数据整理来看下获取的数据，每条数据描述了房子的13个属性，分别为：区、小区、户型、面积、朝向、区域（区下面更细分的一级，比如昌平的天通苑、回龙观）、楼层、房龄、学区、地铁、税、总价、单价。 区，原始数据都是英文代号，比如BJCP代表昌平，BJCY代表朝阳，为了查看起来方便，将它们都替换为相应的中文名。 楼层，原始数据大部分是以“低楼层”、“中楼层”这样的楼层区间划分的，不过有少量数据也写了具体楼层，我统一把它替换为楼层区间。 学区和地铁，我进行了简化，只进行了是否学区、是否地铁的划分，对于学区的品质，地铁的远近没有细分。 税，抓取的30000条数据里面很奇怪只有“满五唯一”和空值这两种，并没有例如“满二不唯一”、“满二唯一”等类型，为了简化，就认为空值没有免税。 对异常值的处理，查看了一下数据，通过与网站上同区域同小区的数据对比，有一些年代过早、总价、单价过高过低等异常情况，比如年代为1000年的房子，总价43亿的“西山小镇”等等，这可能是信息录入员笔误或者采用了默认值造成，由于异常值占比较小，我进行了简单的删除处理。 为了对面积、年代这样的连续值进行分组，我增加了四列， 面积分组：0~50, 50~100, 100~150, 150~200, &gt;200 年代分组：=2015 总价分组：0~1, 1~2, 2~3, 3~4, 4~5, 5~6, 6~7, 7~8, 8~9, 9~10,>10，单位为百万 单价分组：0~1万, 1~2万, 2~3万, 3~4万, 4~5万, 5~6万, 6~7万, 7~8万, 8~9万,9~10万, &gt;10万 整理完共有29790条数据，这是数据的结构： 123456789101112131415161718## &apos;data.frame&apos;: 29790 obs. of 17 variables:## $ area : Factor w/ 15 levels &quot;昌平&quot;,&quot;朝阳&quot;,..: 2 13 7 7 15 5 6 14 2 11 ...## $ region : Factor w/ 5139 levels &quot;@北京&quot;,&quot;10AM新坐标&quot;,..: 674 2299 1789 1955 1063 463 2764 407 2480 2601 ...## $ zone : Ord.factor w/ 53 levels &quot;0室0厅&quot;&lt;&quot;0室1厅&quot;&lt;..: 12 27 12 6 11 16 11 6 6 16 ...## $ meters : int 67 408 75 47 83 136 68 57 55 128 ...## $ direction: Factor w/ 50 levels &quot;&quot;,&quot;北&quot;,&quot;北东北&quot;,..: 40 26 27 26 26 27 27 26 2 27 ...## $ con : Factor w/ 221 levels &quot;CBD二手房&quot;,&quot;安定门二手房&quot;,..: 169 158 132 207 196 215 189 201 73 114 ...## $ floor : Ord.factor w/ 4 levels &quot;地下室&quot;&lt;&quot;低楼层&quot;&lt;..: 2 2 2 4 3 2 3 4 3 3 ...## $ year : int 2000 2002 1996 1997 2007 2010 2011 2008 2000 1998 ...## $ school : Ord.factor w/ 2 levels &quot;无学区&quot;&lt;&quot;有学区&quot;: 2 2 1 1 1 1 1 1 1 1 ...## $ subway : Ord.factor w/ 2 levels &quot;无地铁&quot;&lt;&quot;有地铁&quot;: 2 1 2 1 1 1 1 2 2 1 ...## $ tax : Factor w/ 2 levels &quot;非免税&quot;,&quot;满五年唯一&quot;: 1 1 1 1 1 1 1 1 1 1 ...## $ num : int 360 950 290 260 95 350 220 120 180 205 ...## $ price : int 53732 23285 38667 54622 11446 25736 32353 21053 32728 16016 ...## $ meters_cg: Ord.factor w/ 5 levels &quot;0~50&quot;&lt;&quot;50~100&quot;&lt;..: 2 5 2 1 2 3 2 2 2 3 ...## $ year_cg : Ord.factor w/ 7 levels &quot;&lt;1990&quot;&lt;&quot;90~95&quot;&lt;..: 4 4 3 3 5 6 6 5 4 3 ...## $ num_cg : Ord.factor w/ 11 levels &quot;0~1&quot;&lt;&quot;1~2&quot;&lt;&quot;2~3&quot;&lt;..: 4 10 3 3 1 4 3 2 2 3 ...## $ price_cg : Ord.factor w/ 11 levels &quot;0~1万&quot;&lt;&quot;1~2万&quot;&lt;..: 6 3 4 6 2 3 4 3 4 2 ... 三、数据概览下面从总体上看下数据， 1.县区分布 本次抽到的数据包括北京13个区和2个特别区域亦庄和燕郊，后两个地方不是区，但是在北京的朋友都知道，这两个地方有可能比某些区还有名。 总体来看市区的二手房市场比较活跃，可以看到朝阳、海淀、丰台分列三甲，三个区的二手房之和几乎占去了北京二手房一半的数量，朝阳一个区的岀房量更是比后两名都多。昌平区和燕郊紧随其后，昌平区有天通苑和回龙观这两个人口聚集区（这个后面会看到），而燕郊满足了一些在城区无法买房，又要在市区工作的人的需求，二手房数量也是不容小觑。 2.户型分布 最多的是两室一厅，占到33%，然后是一室一厅、三室两厅、三室一厅这样的户型。 看来小户型还是主流，不过这有可能因为一是大部分二手房年代较早，小户型较多,不过查看了下数据，2000年以后的房子二室一厅也有26%；另外一点可能是北京房价太贵，作为购房者的主体普通大众大部分购买力有限，开发商盖房的时候主要盖的就是这种户型。 3.面积分布 右上角密度图显示本次抽取的数据，面积的区间为0 ~ 3000平方，不过大部分的房子的面积还是集中在一个较小的范围内。从下图可以看到大部分面积都落在50 ~ 150这个区间，50 ~ 100的房子约为54%，而200平米以上的大房子仅为6%。 不太清楚其他地方的房子，在北京房子的面积和要交的税是有关系的。这可能在一定程度上会遏制房子的面积。 4.朝向分布 买过房的都知道，朝向很重要。什么东西向的只有早晚才能见阳光，北向的天天喝西北风，衣服都晒不干，还有一些风水上的讲究就更复杂了，反正我是不懂，凡此种种，充分说明了买房者对朝向的注重。 由于朝向比较多，这里只挑选了数量最多的10种。从图上我发现南北向、南向这些大家都比较喜欢的朝向竟然最多，二者合起来约有61%，这点和自己的看房经历不太一样，咋看有点不可思议，细想原因可能是这样的，一般楼房建设的时候，都是南北朝向的，我想没有哪个傻帽故意把房子盖成朝北的，盖好以后一些边角没有办法，朝向为东西、北等等，所以主体还是南北。 5.区域分布 由于区域众多，我这里只选择了出房量最多的10个区域。从上图可以看到，二手房数量最多的10个区域恰恰也是北京人口较为密集的区域，10个区域朝阳3个，昌平2个，房山1一个，顺义1个，门头沟1个，石景山1个，燕郊1个。 前面我们看到，北京二手房数量以朝阳为最，朝阳以望京为最，望京一个区域占了朝阳12%的房产数量。而天通苑、回龙观也不负众望，分别为第三和第四，另外如良乡、顺义城等我们熟知的人口聚居区交易也异常火爆，假如岀房量能在一定程度上代表交易量的话。 6.楼层分布 买房者对楼层的重视也是不言而喻，众所周知，顶层和低层的房子一般人都不太喜欢，顶层房子冬天冷夏天热，低楼层比较潮湿等等，这两种房子住起来不是那么舒服，所以我原本以为卖房的大部分是这两种楼层。 不过从数据上看，楼层分布比较平均，这点也和自己的看房经历不太一样，从自己的看房经历来看中楼层较少，大部分的二手房都是高楼层或者低楼层。原因可能和楼层的划分有关系，比如一座20层的楼房，1 ~ 5为低层，6 ~ 15为中层，16 ~ 20为高层，这样中楼层就比较多了。 7.建筑年代分布 房子的建筑年代对于土豪不是那么重要，但是对于普通购房者就不一样了，因为贷款的年限和房龄是有关系的。一般情况下钢混结构带电梯的贷款年限为57减去房龄，砖结构比如6层不带电梯的板楼是45减去房龄，具体的年限和你的房屋具体评估值有关系，我在网上找了半天，没有找到这种算法的明文规定，这应该是一个经验值，不过具有一定的准确性。也就是说你想贷款30年，钢混的必须至少为88年后的，砖混的必须至少是2000年后的。 数据显示，建筑年代区间为1952 ~ 2015，从图中可以看到，建筑年代主要集中在1995年到2015年这个时间段，2000年后的房子竟然占了总量的72%。这是我没有想到的，因为看房的时候，看到的房子基本上都是90年代的房子，这可能和当初我的定位有关系，当初买房的时候就想买个离市区近点的，上班方便，房子老点没关系，而市区可能新房子较少。 8.学区房、地铁房、免税房 这三个属性有点相似，放在了一起。这里没有对学区的优劣，地铁的远近等进行细分，只是简单粗暴的分为有无两种。 从图上可以看到学区的差异性较大，学区房只占总量的20%，怪不得学区房这么贵了；而地铁就较为普遍了，随着北京城市交通的建设地铁越来越多，表现在住房上就是地铁房的比例越来越高，约占41%，相信随着城市的发展，这个比例会越来越高。 税费这一项对于普通购房者也很重要，例如满五唯一只有1%的契税，满二唯一还要加收差价20%的个税，具体的费率和是否首套，房屋面积也有一定的关系，买房的朋友可以去查查。 数据显示，满五唯一的房子约为38%，比例不算低，看来，虽说大部分的房子都是2000年后的房子，有相当一部分的人还是在房子满五年之后再出售，虽然房主可以把税费转移到购房者身上，但是定价太高，房屋就不好出了，所以国家的征税政策对房产的恶意交易是有一定的作用的。 9.总价分布 对于总价和单价两种数据，我都是抱着猎奇的态度看待的，不过这两个数据的重要性自不必说，特别是总价，因为这关系到你的预算。看密度图（单位为万元），还真有3亿元的房子，我应该没数错0的个数，不过好在这样的房子只是凤毛麟角，让我等凡人还有些念想。 从直方图上可以看出100 ~ 300万的房子大概有50%，不过大于500万的房子也占到了17%，还得好好努力挣钱啊。 10.单价分布 单价对于普通购房者可能不够直接，因为在我看来，一般人买房之前先确定了总价，也就是自己能拿出多少钱，然后再结合自己大致的需求，比如想要一个多大的，什么户型的等等，总价和需求定了基本上能购买的单价也就定了，也就是说单价影响你选择的余地，比如说你本来想买个100平方的，你在看房过程中特别中意一个小区，那个小区单价贵，你能拿出的钱就那些，那你只能换一个小点的房子了。 密度图（单位元）显示还有30万一平方的房子，赶紧看看是何方宝地，原来是两套5平方的学区房，好吧，喝口水压压惊。不过好在单价主要还是集中在1 ~ 5万的区间，约占80%，其中2 ~ 4万最多，约为总量的50%。 上面大致看了下数据的总体情况，并尝试对一些原因做了分析，当然有些只是推测，这段时间比较忙，正好趁阅兵放假的时间看看能不能从数据中发现一些有利的证据。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"R","slug":"R","permalink":"https://pingao777.github.io/tags/R/"},{"name":"Python","slug":"Python","permalink":"https://pingao777.github.io/tags/Python/"},{"name":"统计","slug":"统计","permalink":"https://pingao777.github.io/tags/统计/"}]},{"title":"大道至简：朴素贝叶斯分类器","slug":"大道至简：朴素贝叶斯分类器","date":"2017-11-16T13:41:58.000Z","updated":"2018-07-29T11:45:57.460Z","comments":true,"path":"2017/11/16/大道至简：朴素贝叶斯分类器/","link":"","permalink":"https://pingao777.github.io/2017/11/16/大道至简：朴素贝叶斯分类器/","excerpt":"万物之始,大道至简,衍化至繁。 ——ifelse(is.element(this, 道德经), 道德经, unknown) 一、背景提到贝叶斯分类，首先来看下贝叶斯其人，贝叶斯(Thomas Bayes,1701—1761)英国牧师、业余数学家。可别小看了欧洲的牧师，孟德尔，被誉为“遗传学之父”也曾为一名神父，假如你不记得孟德尔是谁，那么你肯定记得高中生物上那个著名的豌豆实验。","text":"万物之始,大道至简,衍化至繁。 ——ifelse(is.element(this, 道德经), 道德经, unknown) 一、背景提到贝叶斯分类，首先来看下贝叶斯其人，贝叶斯(Thomas Bayes,1701—1761)英国牧师、业余数学家。可别小看了欧洲的牧师，孟德尔，被誉为“遗传学之父”也曾为一名神父，假如你不记得孟德尔是谁，那么你肯定记得高中生物上那个著名的豌豆实验。 具有讽刺意味的是，当初贝叶斯发明概率统计理论是为了证明上帝的存在，而至死这个愿望都没有实现，不过感谢伟大的贝叶斯，因为他的无心插柳，才有了今天的贝叶斯公式。接下来，来一睹贝叶斯公式的风采， $$P(B|A)=\\frac{P(B)P(A|B)}{P(A)}$$ 公式看起来是不是很简洁，看起来很有对称美。记得上学那会数学老师的一句话，假如你算出来的答案不够简洁，那么多半这道题你算错了。贝叶斯公式有什么意义呢？它解决了两个事件条件概率的转换问题。比如说，已知感冒导致流鼻涕的概率，那么流鼻涕有多大的概率感冒呢？贝叶斯可以解决这类问题。 二、贝叶斯分类 贝叶斯可以解决条件概率转换，可是它怎么与分类联系起来的呢？ 让我以一个例子加以说明，假设有这样一个数据集（本例来自朴素贝叶斯分类器的应用）， 症状(A1) 职业(A2) 疾病(B)打喷嚏 护士 感冒打喷嚏 农夫 过敏头痛 建筑工人 脑震荡头痛 建筑工人 感冒打喷嚏 教师 感冒头痛 教师 脑震荡 那么一个打喷嚏的建筑工人是感冒还是没感冒呢？根据贝叶斯定理， P(感冒|打喷嚏x建筑工人) = P(打喷嚏x建筑工人|感冒) x P(感冒) / P(打喷嚏x建筑工人) 假定”打喷嚏”和”建筑工人”这两个特征是独立的，因此，上面的等式就变成了 P(感冒|打喷嚏x建筑工人) = P(打喷嚏|感冒) x P(建筑工人|感冒) x P(感冒) / P(打喷嚏) x P(建筑工人) = 0.66 x 0.33 x 0.5 / 0.5 x 0.33 = 0.66同理，P(非感冒|打喷嚏x建筑工人) = P(打喷嚏|非感冒) x P(建筑工人|非感冒) x P(非感冒) / P(打喷嚏) x P(建筑工人) = 0.33 x 0.33 x 0.5 / 0.5 x 0.33 = 0.33 因为P(感冒|打喷嚏x建筑工人) &gt; P(非感冒|打喷嚏x建筑工人) ，所以我们更愿意相信一个打喷嚏的建筑工人是感冒的。 从上面的例子可以看出，贝叶斯分类的步骤是这样的： 设$x = {a_1,a_2,\\cdots}$为一个待分类项，每个a为x的一个特征属性。 有类别集合$C = {y_1,y_2,\\cdots,y_n}$. 根据训练集计算，$P(y_1|x), P(y_2|x),\\cdots,P(y_n|x)$. 如果$P(y_k|x)=max{P(y_1|x), P(y_2|x),\\cdots,P(y_n|x)}$，则$x$的分类为$y_k$。 说到贝叶斯分类，还有几个需要注意的问题： 如果已知条件不止一个属性，二是多个呢，这个时候贝叶斯公式可以写作$$P(y|a_1a_2\\cdots)=\\frac{P(y)P(a_1a_2\\cdots|y)}{P(a_1a_2\\cdots)}=\\frac{P(y)P(a_1|y)P(a_2|y)\\cdots}{P(a_1)P(a_2)\\cdots}$$上述公式假设特征属性$a_1,a_2\\cdots$相互独立，这也是“朴素”一词的由来。另外，可以看到对于不同的分类，分母都是恒定的，而我们只想找到概率最大的类别，因此可以把分母省略，求条件概率的相对值，$$P(y|a_1a2\\cdots){relative}=P(y)P(a_1|y)P(a_2|y)\\cdots$$ 不知道大家有没有注意到，上面的已知条件都是离散值，如果是连续值呢，对于连续值通常有两种办法，一是将连续值截取为离散值，然后求概率，二是假定离散值服从高斯分布，即$$f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}exp(-\\frac{(x-\\mu)^2}{2\\sigma^2})$$因为我们只需求概率的相对值，所以这里只需计算属性的概率密度值即可。 还有一个问题，当某些类别下某个特征值计数为0，即$P(a_i|y_j)$=0，这会使某些分类最终的概率为0，会降低分类器的准确性，为了解决这个问题，引入Laplace校准，就是对这些类别的某些特征值计数加1，这样如果训练样本集数量充分大时，并不会对结果产生影响。 如果想更详细的了解贝叶斯分类，请参考这两篇文章分类算法之朴素贝叶斯分类和朴素贝叶斯分类器的应用。 接下来，我用R语言实现一个分类器并用一些数据集测试分类效果。 三、算法实现 程序主要由三部分组成： 分类器主要由下面几个函数组成，具体的代码见GitHub。 123456789# 1.求各个分类概率P(ycol)get.ytable &lt;- function(ycol, trainset)# 2.1求离散属性xcol的条件概率P(xcol|ycol)get.discrete.xtable &lt;- function(xcol, ycol, trainset)# 2.2求连续属性xcol的概率密度，假设服从高斯分布get.continout.xdensity &lt;- function(xcol, ycol, trainset)# 3.对于某些概率为零的类别，采用Laplace校准设置默认值get.defaultx &lt;- function(ycol, trainset)# 注：xcol特征属性，ycol类别属性，trainset训练集 下面以基础包里的iris数据集验证一下分类器的效果，选取前四列为特征，预测鸢尾花的种类， 图上有两条曲线，黑色为我实现的贝叶斯分类器，红色虚线为e1071包里的一个贝叶斯分类器实现。观察可得，随着训练集样本数的增加，测试集的分类正确率越来越高。 再来看看特征属性的选取对正确率的影响， 这次只选择了第二列（花萼宽度）作为特征值，可以看到正确率明显下降了。 再来看一个多分类问题，采用北京二手房这个数据集， 通过房价和是否学区这两列来预测房子所在的区，可以看到这两个特征属性的预测正确率稳定在0.4左右，下面再添加户型、朝向、楼层三列， 上图显示，添加了三个特征属性后，正确率并没有明显的改善，但是如果再添加一个区域列(con)， 由图观察，添加了区域这一列后，正确率得到了大幅度的提升，事实上仅保留区域这一列，预测的正确率也很高，这是因为区域(con)与区(area)的相关性较强。 根据我实验的结果，通常情况下，提高预测正确率的方法有两种： 增加训练集样本数，但是样本到达一定的数目正确率就保持稳定，很难再提高了。 选取恰当的特征，注意单纯的增加特征数目并不能提高正确率，反而会引入更多的误差造成过拟合。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://pingao777.github.io/tags/机器学习/"},{"name":"贝叶斯","slug":"贝叶斯","permalink":"https://pingao777.github.io/tags/贝叶斯/"}]},{"title":"他们征友（婚）时，他们征什么？","slug":"他们征友（婚）时，他们征什么？","date":"2017-11-16T13:36:30.000Z","updated":"2018-07-29T12:22:12.439Z","comments":true,"path":"2017/11/16/他们征友（婚）时，他们征什么？/","link":"","permalink":"https://pingao777.github.io/2017/11/16/他们征友（婚）时，他们征什么？/","excerpt":"有道是年年岁岁花相似，岁岁年年征友人，征友贴一茬又一茬，简历投了一波又一波，为什么迟迟得不到回复？当男女征友时，他们到底在征什么？你真的看懂征友贴了吗？你还在为你屡屡投条未收到答复而苦恼吗？你还在为简历被女神刷掉自怨自艾吗？","text":"有道是年年岁岁花相似，岁岁年年征友人，征友贴一茬又一茬，简历投了一波又一波，为什么迟迟得不到回复？当男女征友时，他们到底在征什么？你真的看懂征友贴了吗？你还在为你屡屡投条未收到答复而苦恼吗？你还在为简历被女神刷掉自怨自艾吗？ 本文以北邮人论坛征友贴为主要原料，使用独家秘制八卦手法，希望从中发现一些有意思的事，本着娱乐至上，看热闹不嫌事大的原则，有些观点和分析请观者自行甄别，图例中F(emale)代表女生，M(ale)代表男生。 一、总体情况首先是大家喜闻乐见的我邮男女比例，如下图所示， 我从论坛总共扒拉下来274个帖子，其中女征男148个，男征女126个，男女比例大概是1:1.17，好像并没有想象的那么悬殊。从年龄上看征友的主力军还是80后，如下所示， 80后约占66%，几乎是90后的两倍，且男女比例基本持平，是啊90后都26了，80后压力好大啊，想静静。值得一提的是90后征友者，女生明显比男生多。从平均年龄上来看，男生为27.9，女生为27.7，女生稍小。整个年龄区间主要集中在26 ~ 30， 女生中26、27岁的占了四分之一。 下面再来看看大家的发帖时间吧， 可以看到，帖子的发布时间集中在晚上23点左右，这可能是和论坛的十大机制有关系，大家选在这个点发帖，目标是为了十大。有几个帖子是在凌晨发的，但都是男征女，看来女神们都很注重养生啊，不熬夜。一周七天，周一、周二和周末两天帖子数稍多，中间三天稍微少点，总体差别不如上面时间那么明显。 二、征友关键词接下来，重点来了，回到开头我们提出的问题，当男女征友时他们在征什么？ 1、征友者说我选取了男女征友者都提到的高频词，列举如下， 除了“工作”、“生活”、“喜欢”、“性格”、“身高”这些千篇一律的词，还有一些有趣的词。不知道大家注意到那个扎眼的“山东”没，因为身为山东人，对“山东”这个字眼比较敏感，这么多词只有一个关于地域的词汇就是“山东”，我很纳闷为什么“山东”出现在这里，山东人那么多没对象吗，我统计了下，平均约12%的帖子提到了山东。我不知道是山东人征友的比较多还是山东人比较受征友者的欢迎，不管怎样我就当成后者吧，哈哈。大家经常议论的“京户”也出现了，约有14%的帖子，不算很多。另外“感情经历”都是双方比较重视的一点，其他的大家自己看看吧。 2、男生vs女生都说”男人来自火星，女人来自金星“，看过了男女生共同的话题，接下来看看两个来自不同星球的生物有哪些差别呢。 男生说的可以总结为：好“哥们”生于“86年”、“88年”，“收入”不错，有“户口”，有“能力”，“技术”过硬，爱好“羽毛球”、“游泳”、“健身”等，身体“健康”，寻“通情达理”，身高“160”以上妹子，插一句男生那么多都喜欢“羽毛球”吗，感觉没那么多啊。 女生可以总结为：单位“姐姐”、多年“闺蜜”生于“87年”、“90年”、“91年”，“活泼”可爱，性格“独立”，“喜欢运动”，会“做饭”，喜欢“孩子”，寻觅人“在北京”，“有责任”、“有上进心”，成熟“稳重”，“170”、“175”以上汉子，“非诚勿扰”，“哈哈哈”。 是的，我们又看到了万恶的“175”，可以看到男生更多的提到表示自己客观实力的字眼，女生则比较喜欢用一些主观一些的词汇。男生对女生最多的要求是“通情达理”，女生对男生最多的要求是“有责任”。 3、80后vs90后是的我又带节奏了，都说“80后是XXX的一代，90后是XXX的一代”，那么这两代人在择偶观上有没有差别呢？ 80后男生可以总结为“寒窗苦读十余载，一朝成名在今朝，高头马，黄金屋，良人你咋还不来”，90后男生则是“世界那么大，未来那么远，唯一不变的就是寻觅你的心，亲爱的，你在哪里”。 80后女生“爱过，痛过，笑过，哭过，姐累了，想结婚了”，90后女生“爱哭爱笑，爱美食爱运动，一直在路上，我要我自己的未来”。 很明显，80后和90后说的话还是挺不一样的，80后可能更“现实”了。不过我不认为这是出生年代造成的，我更愿意把这看成年龄大小的差别，或者更残酷点，成熟与否的区别，就像现在的自己和20岁那年的自己相比，确实有那么一点不同。 至此，相信你已经大概了解男女征友需求了，下次投简历更有针对些吧。不过这可能并没有什么卵用，毕竟一个看脸的社会-_-。 最后祝征友者都能找到理想的另一半，应征者都能面试成功，该玩的年纪勇敢去玩，该爱的年纪勇敢去爱！","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://pingao777.github.io/tags/数据挖掘/"},{"name":"R","slug":"R","permalink":"https://pingao777.github.io/tags/R/"}]},{"title":"三生万物：决策树","slug":"三生万物：决策树","date":"2017-11-15T13:36:34.000Z","updated":"2018-07-21T12:14:13.285Z","comments":true,"path":"2017/11/15/三生万物：决策树/","link":"","permalink":"https://pingao777.github.io/2017/11/15/三生万物：决策树/","excerpt":"一、概述不知怎么回事，提到决策树我就想起”道生一，一生二，二生三，三生万物“这句话，大概是因为决策树从一个根节点慢慢“长”成一棵树，也要经历“一生二，二生三”的过程。决策树本质上就是一种二叉树，根据特定的标准不停的分成左右两个子树，直到符合某种条件停止。树算法解释性强、简单直观以及接近人的决策方式使它成为流行的机器学习算法之一。当决策树与装袋法(Bag)、提升法(Boosting)结合之后，可以成为更强大的算法。","text":"一、概述不知怎么回事，提到决策树我就想起”道生一，一生二，二生三，三生万物“这句话，大概是因为决策树从一个根节点慢慢“长”成一棵树，也要经历“一生二，二生三”的过程。决策树本质上就是一种二叉树，根据特定的标准不停的分成左右两个子树，直到符合某种条件停止。树算法解释性强、简单直观以及接近人的决策方式使它成为流行的机器学习算法之一。当决策树与装袋法(Bag)、提升法(Boosting)结合之后，可以成为更强大的算法。 决策树按响应值的类型大致分为分类树和回归树，实现决策树的方法也很多，比如CART、ID3、C4.5等等，本文将对CART这种算法进行介绍。 二、算法一棵树要长成要解决两方面的问题，一是如何分，二是何时停。这两点对于分类和回归略有区别，先说如何分，对于定量变量一般是将小于某个值的数据划分为左子树，大于等于某个值的划分为右子树；对于定性变量一般是将等于某个值的划分为左子树，不等于某个值的划分为右子树。那么什么才是一个好的划分呢？分类树大致分为两种，一种是按纯度(Purity)，纯度是通过基尼系数(Gini Index)进行定义的，基尼系数越小，纯度越大，那么划分效果越好。基尼系数的计算方法如下式所示： $$G = \\sum_{k=1}^K\\hat{p}_k(1 - \\hat{p}_k)$$ $\\hat{p}_k$代表第$k$类所占比例，当$\\hat{p}_k$接近0或1时，基尼系数会很小。 另一种标准是互熵(Cross-entropy)，互熵的定义如下： $$D = -\\sum_{k=1}^K\\hat{p}_k\\log\\hat{p}_k$$ 由定义可以看到，和基尼系数类似，当$\\hat{p}_k$接近0或1时，互熵也很小，划分的效果也越好。 回归树则根据方差： $$Variance = \\frac{1}{N}\\sum_{i=1}^N(y_i - \\bar{y})^2$$ $\\bar{y}$代表平均响应值，我们都知道方差是衡量数据变异性的量，因此越小表示回归模型效果越好。 注意上面的纯度、互熵以及方差均是树的一个分枝上的值，总的值要对左右分枝进行加权平均，例如基尼系数的最终值应该这样计算， $$G{total} = \\frac{N{left}}{N} G{left} + \\frac{N{right}}{N} G_{right}$$ $N$表示总的样本数，$N{left}$，$N{right}$分别代表左分枝和右分枝的样本数，互熵和方差的计算方式类似。 说了如何分，那什么时候停呢？一般的惯例是子树中的预测变量或响应值都一样了就可以停止分裂了。有时候这个条件可能有些苛刻，这时候可以设置一个Node Size值，表示叶子节点包含的最小的样本数。分裂过程中如果一个子树的样本数小于等于这个值就停止分裂，分类数取数目最多的那个类，回归树取响应的均值。 说了这么多，下面举个例子，来演示下决策树算法，比如这里有一份城市和农村儿童身高数据，注意这里的数据都是我杜撰的，只是为了演示决策树的算法。如果已知一个儿童身高和性别，如何判断所处的区域？ 身高 性别 地区 100 男 城市 90 女 城市 90 男 农村 80 女 农村 下面尝试根据基尼系数来构造一个分类树，第一次分裂： 身高&lt;100：3/4 x (1/3 x 2/3 + 2/3 x 1/3) + 1/4 x (1 x 0) = 1/3 身高&lt;90：1/4 x (1 x 0) + 3/4 x (2/3 x 1/3 + 1/3 x 2/3) = 1/3 身高&lt;80：0/4 x 0 + 4/4 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 性别=男：2/4 x (1/2 x 1/2 + 1/2 x 1/2) + 2/4 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 性别=女：2/4 x (1/2 x 1/2 + 1/2 x 1/2) + 2/4 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 可以看到前面两个都是1/3，选择哪一个都行，这里我选择第一个最小值：“身高&lt;100”，数据被分为：左子树 身高 性别 地区 90 女 城市 90 男 农村 80 女 农村 右子树 身高 性别 地区 100 男 城市 第二次分裂： 由于右面的子树只有一条数据，因此只需计算左边子树的基尼系数， 身高&lt;90：1/3 x (1 x 0) + 2/3 x (1/2 x 1/2 + 1/2 x 1/2) = 1/3 身高&lt;80：0/3 x 0 + 3/3 x (1/3 x 2/3 + 2/3 x 1/3) = 4/9 性别=女：2/3 x (1/2 x 1/2 + 1/2 x 1/2) + 1/3 x (1 x 0) = 1/3 性别=男：1/3 x (1 x 0) + 2/3 x (1/2 x 1/2 + 1/2 x 1/2) = 1/3 同上选择第一个最低值“身高&lt;90”，数据分成了两部分：左子树 身高 性别 地区 80 女 农村 右子树 身高 性别 地区 90 女 城市 90 男 农村 第三次分裂： 同理，左边子树只有一条数据，只需计算右子树 身高&lt;90：0/2 x 0 + 2/2 x (1/2 x 1/2 + 1/2 x 1/2) = 1/2 性别=女：1/2 x (1 x 0) + 1/2 x (1 x 0) = 0 性别=男：1/2 x (1 x 0) + 1/2 x (1 x 0) = 0 选择“性别=女”这个条件，至此所有的子树的响应值都是唯一的，停止分裂。 最终这个分类树的样子大概如下， 三、树的剪枝其实树的剪枝就是正则化，剪枝一般分为两种：一种称为预剪枝，通过设置Node Size的大小来达到控制树的分枝个数的目的，这种方式简单易用，但有短视的风险；另一种称为后剪枝，原理是让树充分“生长”，然后尝试合并树的分枝，通过对比合并前后错误率是否降低来决定是否真得合并，这种方式效果较前一种好，但是实现稍微复杂一些。 四、说了就练俗话说，光说不练假把式，下面我用R语言实现一个决策树，并尝试分析两个实际的数据集。 1、鸢尾花(iris)数据集，这个数据集包括五个变量：花萼长度(Sepal.Length)，花萼宽度(Sepal.Width)，花瓣长度(Petal.Length)，花瓣宽度(Petal.Width)，种类(Species)，下面尝试使用花萼长度(Sepal.Length)和花萼宽度(Sepal.Width)这两个变量来预测鸢尾花的种类(Species)。 为了简便，我采用的是预剪枝的方式。那么选择多大的Node Size合适呢？关于这个问题通常的方法就是交叉验证(Cross-validation))。下图是采用10折交叉验证(k-fold cross-validation)得到的错误率, 可以看到，当Node Size为40的时候测试集的错误率Eout最低，从另一个方面也可以看到如果不进行剪枝，Eout约为0.4，比剪枝后的错误率高了将近0.2。从下面的第一张图也可以直观的看到当Node Size从小到大增加时，分类边界(Decision Boundary)从过拟合(Overfit)到欠拟合(Underfit)的变化趋势。第二张图是根据交叉验证得到的最佳分类边界，它和Node Size为30的分类边界非常相似。 最终的错误率约为0.2，从上面第二张图可以看到versicolor和virginica这两类的鸢尾花有些数据在二维空间完全重合在了一起，仅仅依靠花萼长度(Sepal.Length)，花萼宽度(Sepal.Width)这两个变量是无法把它们分开的，这个时候单纯的增加样本数无法进一步提高模型的质量，这个时候最好去寻找新的变量，事实上，当加上花瓣长度(Petal.Length)，花瓣宽度(Petal.Width)这两个变量时，预测的错误率可以降低到0.06左右。 树的样子如下， 2、上面是个分类问题，那么再看一个回归问题。北京二手房这个数据集有13个特征，下面使用决策树根据房子的区域(area)、是否学区(school)、是否有地铁(subway)、总价(num)这四个变量来预测房价(price)。 同样，祭出我们的法宝交叉验证得到一个合适的Node Size，如下所示， 对于回归,我采用了决策系数R2作为衡量模型效果的标准，由于R2是越大越好，且0&lt;R2&lt;1，所以这里用1-R2作为模型的误差。和分类树类似，当Node Size从小到大的过程中，模型呈现出了从过拟合到欠拟合的变化过程，显然，当Node Size约为100的时候模型效果是最好的。下图是Node Size为100时从29790条数据中随机选取了10000条进行训练得到的模型，用这个模型预测所有29790条房屋的房价，相对误差((预测房价-实际房价)/实际房价)如下所示， 得到的决策系数R2约为0.7，也就是区域、是否学区、是否有地铁、总价这四个变量解释了70%房价变异。由这个相对误差图可以看出大部分的数据都落在了0附近，实际上有20275条数据落在[-0.2,0.2]，28379条数据落在[-0.5,0.5]。那么，那些误差比较大的都是些什么数据呢？ 123456下面的数据为相对误差大于3的area region zone meters direction con floor year school subway tax num price海淀 东小营甲1号 5室2厅 350 南 西北旺二手房 低楼层 1998 无学区 无地铁 非免税 280 8000朝阳 北苑家园望春园 1室0厅 36 南北 北苑二手房 地下室 2008 无学区 无地铁 非免税 20 5556昌平 香堂文化新村二期 5室4厅 460 南北 昌平其它二手房 低楼层 2010 无学区 无地铁 非免税 220 4783昌平 东亚上北中心 1室0厅 738 北 回龙观二手房 地下室 2007 无学区 无地铁 非免税 370 5012 感觉这些数据好像异常数据，北京还有低于1万的房价？！ 五、总结当一个小小的种子慢慢成长为一颗参天大树，独霸森林一方，常常让人感受生命的强大，而决策树算法同样让人惊叹，易于实现又足够灵活，既能用于分类又能用于回归，也在机器学习领域赢得了一席之地。本文简单介绍了决策树的算法和剪枝，在此基础上用R实现了一个决策树，并在两个数据集上进行了测验，证实了决策树的能力。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"决策树","slug":"决策树","permalink":"https://pingao777.github.io/tags/决策树/"},{"name":"机器学习","slug":"机器学习","permalink":"https://pingao777.github.io/tags/机器学习/"}]},{"title":"VIM中的正则表达式","slug":"VIM中的正则表达式","date":"2017-11-14T03:19:43.000Z","updated":"2018-01-11T14:00:11.204Z","comments":true,"path":"2017/11/14/VIM中的正则表达式/","link":"","permalink":"https://pingao777.github.io/2017/11/14/VIM中的正则表达式/","excerpt":"VIM作为一款编辑软件有着强大的操作指令，灵活的配置方法，通过适当的组合能够实现令人眼花缭乱的功能，而正则表达式作为一门处理文本和数据的重要工具，和VIM异曲同工，通过元字符的简单组合就可以匹配千变万化的文本和数据，它是如此的强大以至于有些任务如果没有正则表达式几乎没有其他好的方法实现。下面看看这两个强大的武器是如何结合在一起的。","text":"VIM作为一款编辑软件有着强大的操作指令，灵活的配置方法，通过适当的组合能够实现令人眼花缭乱的功能，而正则表达式作为一门处理文本和数据的重要工具，和VIM异曲同工，通过元字符的简单组合就可以匹配千变万化的文本和数据，它是如此的强大以至于有些任务如果没有正则表达式几乎没有其他好的方法实现。下面看看这两个强大的武器是如何结合在一起的。 本文翻译自http://www.vimregex.com/，算是一篇比较全面的VIM正则表达式介绍。 2.介绍2.1什么是VIM？VIM（VI Improve）是VI编辑器的改进版，它在UNIX中无处不在。VIM由Bram Moolenaar发明，是一款免费的编辑器，当然如果你愿意，可以捐助一部分钱。 VIM有自己的网站为www.vim.org和邮件列表，上面的资料涵盖VIM的方方面面。目前，VIM能够运行在各大操作系统上，甚至是一些linux发型版本（redhat）的默认编辑器。 VIM拥有现代编辑的许多特点：语法高亮、可以定制化的用户界面、可以方便的与多种IDE集成在一起，从而具有一些更加吸引人的特色，比如故障恢复、自动命令补全、会话管理等。 VIM拥有庞大的用户群，仅linux用户就超过1000万，这个数字还在进一步增加。 2.2关于本教程之所以写这个教程，只是因为我爱正则表达式，没有什么能比写出一个精心设计满足需要的正则表达式更让人兴奋的了，我希望这能作为一个引言。 不过说真的，正则表达式作为一个处理文本和数据的工具不是独立存在，而是嵌入在其他的程序语言或工具中，比如UNIX中的著名的grep程序，它根据一定的模式查找文件中的内容。你可以把正则表达式看做一种模式匹配语言，用它来处理一些棘手的文本问题会有意想不到的效果。 2.3致谢感谢Benji Fisher, Zdenek Sekera, Preben “Peppe” Guldberg, Steve Kirkendall, Shaul Karl（排名不分先后）以及所有给我建议的人。 如果你有好的建议或者想法，随时发信给我（olontir at yahoo dot com）。 3.替换命令3.1查找/替换 :range s[ubstitute]/pattern/string/cgiIc 每次替换都要确认g 替换一行当中所有的匹配项（没有g只替换第一个匹配值，pingao注：注意与%区别）i 忽略大小写I 不忽略大小写 []中表示可选项 3.2范围操作、行地址及标记在讲匹配模式之前，先来了解下行地址。一些命令可以接受行范围，这样命令就会限定在这个范围内执行。行范围通常由逗号（，）或者分号（；）分隔的标示符组成，你也可以使用命令mI在当前位置作一个标记，以方便后面使用，”I”可以是任何字母。 标示符 说明 数字 行号 . 当前行 $ 文件的最后一行 % 整个文件，与1,$相同 ‘t 标记t /pattern[/] pattern的下一个匹配行 ?pattern[?] pattern的上一个匹配行 \\/ 最近一个搜索pattern的下一个匹配行 \\? 最近一个搜索pattern的上一个匹配行 \\&amp; 最近一个替换pattern的下一个匹配行 如果没有指定行，操作只针对当前行。 这里有一些例子， 10, 20 -10到20行 /Section 1/+,/Section 2/- -所有Section 1和Section 2之间的行，不包括它们所在行，+标示加一，-标示减一，可以重复多个 :/Section/+ y -复制Section的下一个匹配行 :// normal p -粘贴到Section下一个匹配行的下一行 Tip1:如果你在pattern里使用/，一定要使用\\进行转义，比如，s/\\/dir1\\/dir2\\/dir3\\/file/dir4\\/dir5\\/file2/g 为了避免这种令人迷惑的转义灾难，VIM中可以自定义分隔符，我喜欢用冒号（:） Tip2：将下面两个快捷键映射放在你的vimrc文件中，noremap ;; :%s:::g&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;noremap ;&#39; :%s:::cg&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;&lt;Left&gt; 有了这两个快捷键，你会省去不少敲击键盘的时间，它会直接定位到搜索模式那里，输入搜索部分后再输入替换部分然后按回车键。第二个快捷键增加了确认标志。 4.模式说明4.1锚假设你想把所有的vi替换为VIM，很容易会想到下面的命令， s/vi/VIM/g 但是如果你真的这么做了，你会发现，它会把所有vi替换为VIM，甚至vi只是某个单词的一部分，这可能不是你想要的。 你可能还会想到，在vi两边添加空格来达到想要的效果， s: vi : VIM :g 你会发现结果并没有变化，正确的方法是使用单词边界标志\\&lt;\\&gt;， s:\\&lt;vi\\&gt;:VIM:g 行开始和结束有自己的标识符^和$，替换所有在行开始出现的vi， s:^vi\\&gt;:VIM: 如果一行之中只有vi则进行替换， s:^vi$:VIM: 现在假设你不仅要替换vi还要替换Vi、VI，有几种方法可以实现， 最简单的方法是使用i标志， %s:vi:VIM:gi 定义字符类（character class），:%s:[Vv]i:VIM:将会替换所有的Vi和vi 4.2转义字符或元字符到目前为止，所有的匹配模式（pattern）都是由一些正常字符组成的，而正则表达式的真正强大之处就在于元字符（metacharacter），元字符是是指一些具有特殊含义的字符，从外观上它们的前面常有一个反斜杠，如下表所示， # 匹配 # 匹配 . 除换行符之外的任意字符 \\s 空白字符 \\S 非空白字符 \\d 数字 \\D 非数字 \\x 十六进制 \\X 非十六进制 \\o 八进制 \\O 非八进制 \\h 单词头（a-zA-Z_） \\H 非单词头 \\p 可打印字符 \\P 非打印字符 \\w 单词字母 \\W 非单词字母 \\a 字母 \\A 非字母 \\l 小写字母 \\L 非小写字母 \\u 大写字母 \\U 非大写字母 比如，你想匹配 09/01/2000，可以使用下面的正则表达式， \\d\\d/\\d\\d/\\d\\d\\d\\d 匹配一个首字母大写的六字母单词， \\u\\w\\w\\w\\w\\w 如果你想匹配一个不知道长度的单词或者一个长单词，写出每个\\w不是很方便，这就要用到下面介绍的量词（quantifiers）概念了。 4.3量词、贪婪匹配与惰性匹配将一个量词（quantifiers）放置在模式（pattern）一部分后面，就可以限制这部分的重复次数。 量词 说明 * 0个或多个，.*匹配任何东西，甚至一个空行 \\+ 1个或多个 \\= 0个或1个（pingao注：相当于?） \\{n, m} 匹配n到m次 \\{n} 匹配n次 \\{, m} 匹配0到m次 \\{n, } 至少匹配n次 n和m都必须是正整数 现在很容易就能写出一个匹配任意长度单词的表达式：\\u\\w\\+。 上面这些量词都是工作在贪婪模式下的，它们会尽可能多的匹配字符。有时候这会带来意想不到的问题，考虑一个典型的例子，假如你想匹配一个含有某种限定符的文本，比如被引号或者括号包围的文本，因为你不知道这些限定符里有什么，我们可以使用/&quot;.*&quot;/。 但是这个表达式将会匹配任何处于第一个引号和最后一个引号中间的文本，如粗体标注的部分 this file is normally “$VIM/.gvimrc”. You can check this with “:version”. 这种问题可以使用惰性（non-greedy）量词来解决， 量词 说明 \\{-} 0个或多个，尽可能少的匹配 \\{-n,m} n个或多个，尽可能少的匹配 \\{-n, } 至少匹配n次，尽可能少的匹配 \\{-, m} 至多匹配m次，尽可能少的匹配 让我们用\\{-}替换上面的*，所以.\\{-}将会匹配第一个引号的内容。 this file is normally “$VIM/gvimrc”. You can check this with “:version”. \\{-}确实没有让我们失望，下面看看执行下面的命令将会发生什么， :s:.\\{-}:_:g 执行前： n and m are decimal numbers between 执行后： n _a_nd m _a_re _d_e_c_i_m_al _n_u_m_b_e_rs _b_e_t_w_e_en “尽可能的少的匹配”在这里的意思是匹配0个字符，然而匹配竟然发生在了字符之间，下面我引用Bram自己的话来解释这种行为， 匹配到0个字符也是一种匹配，因此它会将0字符替换为一个”_”，然后走到下一个位置，继续匹配到0个字符。 大部分情况下，\\{-}没有多大的用处，它的这种运行方式主要是为了和*保持一致，后者也会匹配0个字符，相比之下，x\\{-1,}是一种更加没用的写法，它只会匹配一个x，和x功能一样，比较有用的一种写法为x\\{70}，至于x\\{-3,}&quot;, &quot;x\\{-2,}&quot;, &quot;x\\{-1,}用处也不大，只是为了和贪婪模式的量词保持一致。 -Bram 但是如果你只想匹配第二个引号的内容呢？或者我们只想改变引号中的一部分内容呢？我们将会用到分组（grouping）和反向引用（backreference），在这之前我们先来看下字符区间的概念（character range）。 4.4字符区间典型的字符区间： [012345]将会匹配括号中的任意一个，[0-5]与之等价，类似地，我们可以定义全部小写字母的字符区间[a-z]，所有的字母[a-zA-Z]，数字加字母[0-9a-zA-Z]，根据你所在的区域，你可以在字符区间添加à, Ö, ß这样的非ASCII字符。 注意字符区间仅仅匹配其中的一个字符，[0123]和0123不同，顺序对于一个字符区间不重要，[0123]和[0231]一样，而0123和0231是两个截然不同的模式。看看执行下面的句子会发生什么， s:[65]:Dig:g 执行前： High 65 to 70. Southeast wind around 10 执行后： High DigDig to 70. Southeast wind around 10 然后执行 s:65:Dig:g 执行前： High 65 to 70. Southeast wind around 10 执行后： High Dig to 70. Southeast wind around 10 通过放置一个反选符号（^）在字符区间的最前面可以很容易的去除不愿匹配的字符，下面将会匹配除大写字母外的任意字符， /[^A-Z]/ 我们可以使用字符区间重写匹配引号内的文本， /&quot;[^&quot;]\\+&quot;/ 注意[]内部的元字符会失去其特殊的意义，所以如果你想要一个包含-的字符区间，把-放在最前面，如下表达式将会匹配所有的数字和-， /[-0-9]/ 同时^如果不在最前面，也会失去其特殊意义。 现在考虑一个现实的例子，假设有一个语法检测器想找出所有不以大写字母开头的句子，下面的表达式可以实现这一点， \\.\\s\\+[a-z] 这将会匹配一个句号、一个或多个空格然后是一个小写字母，我们现在知道如何找到错误，下面来看看如何修复它。这里就需要我们记住前面的匹配值以便后面可以重新调用它，这就是反向引用大显身手的地方了。 4.5分组和反向引用你可以使用\\(\\)对模式匹配项进行分组，然后通过\\1, \\2 ... \\9来引用。一个典型的例子为交换每一行的头两个单词， s:\\(\\w\\+\\)\\(\\s\\+\\)\\(\\w\\+\\):\\3\\2\\1: \\1代表第一个单词，\\2代表一个或多个空白符，\\3代表第二个单词。如何知道哪个数字代表哪个匹配项，从左往右数\\(的个数。 # 含义 # 含义 &amp; 模式匹配到的全部内容 \\L 将后面的字符都转换为小写 \\0 同上 \\U 将后面的字符都转换为大写 \\1 第一个括号中匹配的内容 \\E end of \\U and \\L \\2 第二个括号中匹配的内容 \\e end of \\U and \\L … … \\r 将一行分为两行 \\9 第九个括号中匹配的内容 \\I 将下一个字符转换为小写 ~ 前面替换的字符串 \\u 将下一个字符转换为大写 看下上面的语法检查问题完整的表达式， s:\\([.!?]\\)\\s\\+\\([a-z]\\):\\1 \\u\\2:g 我们将0个或多个空白符替换为两个空格。 4.6备选备选（alternation）是指用\\|将多个表达式结合在一起，这样一旦有一个表达式匹配到，则整个表达式匹配成功，返回这个表达式匹配内容。（pingao注：类似于逻辑操作符|） \\(Date:\\|Subject:\\|From:\\)\\(\\s.*\\) 上面的表达式将会把邮件的头部和内容放在\\1和\\2中，对于备选需要注意的是，它不是贪婪匹配的，一旦多个表达式有一个表达式匹配到，后面的表达式将不再匹配，这意味着对于一个备选，表达式的顺序十分重要。 Tip3:将\\(\\)快速的放在表达式中，cmap ;\\ \\(\\)&lt;Left&gt;&lt;Left&gt; 4.7正则表达式操作符的优先级和算数表达式一样，正则表达式的运算符也有一定的优先级，下表从高到低列出了各个操作的优先级， 优先级 操作符 说明 1 \\(\\) 分组 2 \\=,\\+,*,\\{n} 量词 3 abc\\t\\.\\w 字符、元字符 4 “\\ ” 备选 5.全局命令5.1全局搜索及执行我想介绍另一个用处广泛功能强大的命令， :range g[lobal][!]/pattern/cmd在range的范围内，在pattern匹配行执行Ex cmd（默认为:p[rint]），如果pattern前面加上一个!，表示pattern没有匹配的行。 全局命令的工作原理为，第一遍扫描range范围的每一行，并对pattern匹配行做一个标记；第二遍对每一个标记行执行cmd。range默认为整个文件。 注意：Ex command包括所有你在VIM命令行输入的命令，比如 :s[ubstitute], :co[py] , :d[elete], :w[rite] 非Ex command（normal command）也可以执行， :norm[al]non-ex command 5.2例子:g/^$/ d -删除文件中所以的空行 :g/^$/,/./-j -将多个空行转换为一个空行 :10,20g/^/ mo 10 -颠倒10到20行的顺序 下面是一个来自 Walter Zintz vi教程的例子，例子有改动 :&#39;a,&#39;b g/^Error/ . w &gt;&gt; errors.txt -在标记’a和’b之间找到以Error开始的行，然后将这些行追加到errors.txt。注意：w前面的.（当前行）不要漏掉，否则将会把整个文件追加到errors.txt中。 你可以使用|作为分隔符执行多个命令，如果你想在参数中使用|，要用\\对其进行转义。 Zintz的另一个例子， :g/^Error:/ copy $ | s /Error/copy of the error/ 将所有Error行拷贝到文件的最后，然后将Error替换为copy of the error。s命令没有指定地址，默认为当前行。 :g/^Error:/ s /Error/copy of the error/ | copy $ 将上面的操作顺序颠倒了一下，先替换后复制。 6.更多的例子6.1小贴士(1)由Antonio Colombo提供 去掉所有行尾部的空白符， s:\\s*$::或者s:\\s\\+$:: 6.2创建一个大纲这个例子需要你有点html的背景，我们需要将&lt;h1&gt;和&lt;h2&gt;标签中的标题和副标题分离出来，做一个表格。 (1)首先我们给每个标签做一个标记，&lt;h1&gt;&lt;a name=&quot;anchor&quot;&gt;Heading&lt;/a&gt;&lt;/h1&gt;，anchor是标签的唯一标示，实现表达式如下， 1:s:\\(&lt;h[12]&gt;\\)\\(.*\\s\\+\\([-a-zA-Z]\\+\\)\\)\\s*\\(&lt;/h[12]&gt;\\):\\1&lt;a name=&quot;\\3&quot;&gt;\\2&lt;/a&gt;\\4: 说明： (2)接下来，将标题拷贝到一个地方， :%g/&lt;h[12]&gt;/ t$ 上面的命令将会把&lt;h1&gt;和&lt;h2&gt;标签所在行拷贝到文件的最后。现在文件的样子如下， 12345&lt;h1&gt;&lt;a name=\"anchor1\"&gt;Heading1&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=\"anchor2\"&gt;Heading2&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2&gt;&lt;a name=\"anchor3\"&gt;Heading3&gt;&lt;/a&gt;&lt;/h2&gt;..........................&lt;h1&gt;&lt;a name=\"anchorN\"&gt;HeadingN&gt;&lt;/a&gt;&lt;/h1&gt; 第一步，为了要把表格的元素链接到各自的位置，我们要把name=&quot;替换为href=&quot;#。 s:name=&quot;:href=&quot;#: 第二步，要让h1与h2看起来不同，我们定义”majorhead”和”minorhead”两个CSS类， 12g/&lt;h1&gt;/ s:&lt;a:&amp; class=&quot;majorhead&quot;:g/&lt;h2&gt;/ s:&lt;a:&amp; class=&quot;minorhead&quot;: 现在文件看起来像这样， 12345&lt;h1&gt;&lt;a class=\"majorhead\" name=\"anchor1\"&gt;Heading1&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a class=\"minorhead\" name=\"anchor2\"&gt;Heading2&gt;&lt;/a&gt;&lt;/h2&gt;#（pingao注：我认为此时文件应该是这样的）&lt;h1&gt;&lt;a class=\"majorhead\" href=\"#\"&gt;Heading1&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a class=\"minorhead\" href=\"#\"&gt;Heading2&gt;&lt;/a&gt;&lt;/h2&gt; 我们不再需要&lt;h1&gt;和&lt;h2&gt;标签， s:&lt;h[21]&gt;:: 替换&lt;/h1&gt;和&lt;/h2&gt;标签为&lt;br&gt;， s:/h[21]:br: 现在文件的样子， 12345&lt;a class=\"majorhead\" name=\"anchor1\"&gt;Heading1&gt;&lt;/a&gt;&lt;br&gt;&lt;a class=\"minorhead\" name=\"anchor2\"&gt;Heading2&gt;&lt;/a&gt;&lt;br&gt;#（pingao注：我认为此时文件应该是这样的）&lt;a class=\"majorhead\" href=\"#\"&gt;Heading1&gt;&lt;/a&gt;&lt;br&gt;&lt;a class=\"minorhead\" href=\"#\"&gt;Heading2&gt;&lt;/a&gt;&lt;br&gt; 6.3处理表格很多情况下，你需要处理表格形式的文本。例如，下面的文本， 123456789Asia America Africa EuropeAfrica Europe Europe AfricaEurope Asia Europe EuropeAsia America Africa EuropeAfrica Europe Asia AfricaEurope Asia Asia EuropeEurope America Africa AsiaAfrica Europe Europe AfricaEurope Asia Europe Europe 假设你想把第三列的”Europe”替换为 “Asia”， :%s:\\(\\(\\w\\+\\s\\+\\)\\{2}\\)Europe:\\1Asia: 交换前两列， :%s:\\(\\w\\+\\)\\(.*\\s\\+\\)\\(\\w\\+\\)$:\\3\\2\\1: 未完待续… 7.其他语言正则表达式特点现在我将VIM的正则表达式与其他语言的正则表达式做一个对比，特别是Perl。提起正则表达式，Perl肯定不得不提。 （在Steve Kirkendall的帮助下整理）Perl和VIM的主要区别为， Perl的大多数元字符不需要反斜杠。个人认为，反斜杠越少越好，这样正则表达式会更加可读。 Perl中你可以在量词后加上一个?将贪婪模式的量词转换为非贪婪模式， 比如*?为非贪婪模式的*。 Perl的正则表达式支持各种奇怪的选项。 Perl的正则表达式可以包含变量，变量将会替换为具体的值，这称作”变量替换”。 8.链接在正常模式下，输入”:help pattern”，阅读VIM帮助文档的正则表达式和搜索章节。 市场上有两本不错的介绍VIM正则表达式的书， “Learning the vi Editor” by Linda Lamb and Arnold Robbins. “vi Improved - VIM” by Steve Oualline Jeffrey Friedl的”Mastering Regular Expressions”是一本正则表达式的权威指南，此书主要介绍Perl的正则表达式，由O’Reilly出版，官网上有一章免费。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://pingao777.github.io/tags/Vim/"}]},{"title":"统计中的p值","slug":"统计中的p值","date":"2017-11-14T02:39:23.000Z","updated":"2018-07-20T22:22:09.457Z","comments":true,"path":"2017/11/14/统计中的p值/","link":"","permalink":"https://pingao777.github.io/2017/11/14/统计中的p值/","excerpt":"在我看来，假设检验从本质上是一种反证法。当你想证明一样事物是对的，有时候不太好证明，因为一件你以为对的东西可能只是因为你还没发现它错的一面，相反你想证明一件事物是错的就容易多了。在假设检验中，证明备择假设H1存在困难，我们就去证明它的反面原假设H0。","text":"在我看来，假设检验从本质上是一种反证法。当你想证明一样事物是对的，有时候不太好证明，因为一件你以为对的东西可能只是因为你还没发现它错的一面，相反你想证明一件事物是错的就容易多了。在假设检验中，证明备择假设H1存在困难，我们就去证明它的反面原假设H0。 p值一直是一个令人迷惑的地方，p值实际上是当H0假设为真，一些极端情况出现的概率。即$$p值 = {极端情况概率|H0}$$ 那么极端情况是什么呢？在H0的前提下，假设样本均值符合正态分布，我们都知道偏离均值3个均方差的概率几乎为0，但是这种情况还是出现了，我们就有理由判断前提条件错了，即H0是错的，由此我们拒绝H0。 上面提到在正态分布的情况下，偏离均值3个均方差的概率几乎为0，但毕竟不是0，事实上约为0.27%。虽然概率很小，但是还是有一定的可能性会拒绝本是正确的H0，这个犯错概率称为第一类错误，也称为显著性水平$\\alpha$。 那么，这个显著性水平$\\alpha$和p值有什么关系呢？在我看来就是拒绝一个真H0所允许的最大错误概率，也就是这种极端情况出现的最高概率，当p小于等于$\\alpha$时我们拒绝H0，否则不能拒绝H0。 在假设检验中，通常的流程为： 提出原假设和备择假设。 指定显著性水平$\\alpha$，通常取0.01或0.05。 搜集样本数据计算检验统计量的值。 利用检验统计量的值计算p值。 如果p值&lt;=$\\alpha$，则拒绝H0，否则不能拒绝H0。","categories":[{"name":"技术人生","slug":"技术人生","permalink":"https://pingao777.github.io/categories/技术人生/"}],"tags":[{"name":"统计","slug":"统计","permalink":"https://pingao777.github.io/tags/统计/"}]}]}